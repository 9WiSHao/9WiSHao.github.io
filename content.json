{"meta":{"title":"WiSHao'blog","subtitle":"WiSHao的博客","description":"终于开始记点东西","author":"WiSHao","url":"http://wishao.me","root":"/"},"pages":[{"title":"","date":"2023-12-05T03:52:45.703Z","updated":"2023-07-11T01:55:09.268Z","comments":true,"path":"404.html","permalink":"http://wishao.me/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-12-05T03:52:45.703Z","updated":"2023-07-11T02:15:52.215Z","comments":true,"path":"about/index.html","permalink":"http://wishao.me/about/index.html","excerpt":"","text":"我 小前端一个，被基友坑入门，一入门深似海，但是意外还挺喜欢，就一直在学 音游人，这是我的osu主页，主玩戳泡泡，球球osu大申带带 其他没什么可说的。虽然说现在的互联网上根本没有隐私可言，但是我也没有义务在这做我的简历。为我留下最后的一份神秘，好吗？若想知道更多，可以去翻我的社交账号。 碎碎念虽说自高中毕业的暑假就想搭建自己的博客了，但是初期实在是技术不足，连教程看着都费劲，就不了了之。后来学习了一些知识，却深陷我的强迫症，找不到我满意的主题。就像历史上许多重大事件都是由意外推动的一样，某天有不可抗力突然给了我一晚上的限制让我必须搭建好我的博客，我居然在几小时内完成了主题的挑选，不可思议。 差不多就这样了，或许我写的东西会很水，无所谓了，反正没人看，有个地方放点东西也挺好，也没想给谁看。如果你无意间翻看到了我的博客，恭喜你，有缘人，或许可以加一下我的社交账号？"},{"title":"所有分类","date":"2023-12-05T03:52:45.703Z","updated":"2023-07-10T14:22:24.659Z","comments":true,"path":"categories/index.html","permalink":"http://wishao.me/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-12-05T03:52:45.703Z","updated":"2023-07-10T13:42:32.150Z","comments":true,"path":"tags/index.html","permalink":"http://wishao.me/tags/index.html","excerpt":"","text":"点击查看含此标签的文章"},{"title":"我的朋友们","date":"2023-12-05T03:52:45.708Z","updated":"2023-07-10T13:32:53.949Z","comments":true,"path":"friends/index.html","permalink":"http://wishao.me/friends/index.html","excerpt":"","text":"欢迎捧场"}],"posts":[{"title":"uni-app 支付宝小程序开发踩坑记录","slug":"uni-app-支付宝小程序开发踩坑记录","date":"2023-11-20T15:44:44.000Z","updated":"2023-12-05T03:51:57.553Z","comments":true,"path":"2023/11/20/uni-app-支付宝小程序开发踩坑记录/","link":"","permalink":"http://wishao.me/2023/11/20/uni-app-%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"支付宝小程序， ios 上音频播放失败、DOM 魔改、ref 引用等各种各样的坑 我选了两个垃圾平台，自己踩了两倍的坑 1、踩坑之 ios 音频播放失效","text":"支付宝小程序， ios 上音频播放失败、DOM 魔改、ref 引用等各种各样的坑 我选了两个垃圾平台，自己踩了两倍的坑 1、踩坑之 ios 音频播放失效 坑比如说一个简单的 uniapp 的音频播放，下面俩函数绑定到对应的播放停止按钮上。代码如下 123456789101112const testaudio = uni.createInnerAudioContext();testaudio.src = &#x27;https://m701.music.126.net/20231121002122/6cab596b822faccb93fdf042dadb9bcc/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/31223625128/85a6/7924/89bd/de76bcf275daa45deba6da310e78c31c.m4a&#x27;;testaudio.onCanplay(() =&gt; &#123; console.log(&#x27;音频1加载完成&#x27;);&#125;);function play1() &#123; testaudio.play();&#125;function stop1() &#123; testaudio.pause();&#125; uniapp 编译到支付宝小程序了，然后我使用真机测试，成功播放。但是诡异的就是我朋友的手机测试失败。 一连试了好几个人，发现是安卓能正常播放，ios 失败，太诡异了。 但是那个加载完成又是实打实的，就是播放出了问题。 支付宝开发者平台文档啊，社区啊看了半天，然后发现一个问同样问题的，时间停止在 23 年 3 月，没人回，没解决。 我服了，这么严重的功能问题，支付宝小程序你那文档怎么写的，ios 放不出来音频啊，近一半的用户啊 解决最后 google 了一晚上，瞎试了好多方法，还去看了微信小程序社区，最后解决了。 ios 有个默认全局静音的策略，支付宝 app 估计是开了，需要给音频设置静音也能播放才行 1testaudio.obeyMuteSwitch = false; 设置完再给朋友手机真机测试，音频放出来了，我也成功因为支付宝平台的垃圾文档浪费了一晚上时间 2、踩坑之音频 audioContext 对象只能同时存在 6 个坑在做无障碍组件，盲人使用，所以需要音频播放 我的解决方案就是先把现成的音频放到 oss 对象储存上，然后获取外链，直接播放 uniapp 里音频播放大概要这么写 1234567let audio = uni.createInnerAudioContext();audio.src = &#x27;xxxx.xxxxx.url&#x27;;// 这个必须写，不然ios放不出声音audio.obeyMuteSwitch = false;audio.onCanplay(() =&gt; &#123; audio.play();&#125;); 本来打算直接给每个组件都这么直接 new 好，然后点击直接调用 audio.play 完事 结果发现放多了音频之后，前面最早弄的就放不出声音来了 解决反复实验发现，支付宝小程序是同时只能存在 6 个 audio 上下文 audioContext 对象，多了的话后面的会覆盖前面的，也就放不出声音来了 所以解决就是随用随 new，放完就释放。大概就是这样 123456789101112131415let audio: UniApp.InnerAudioContext | null;function audioCreatePlay() &#123; audio = uni.createInnerAudioContext(); audio.src = props.audioUrl; // 这个必须写，不然ios放不出声音 audio.obeyMuteSwitch = false; audio.onCanplay(() =&gt; &#123; audio?.play(); &#125;);&#125;// 用audioCreatePlay();// 用完直接释放audio?.destroy();audio = null; 3、踩坑之注意 vue3 单项数据流坑好吧这个其实跟 uniapp 没啥关系，纯纯是我不遵守 vue 规范 我试图直接在父组件用ref()声明完响应变量之后，直接传递引用给子组件，然后子组件拿着变量引用改变此变量，能让父组件的此 ref 变量变化 结果当然是不行 解决这么写没遵守 vue 框架单项数据流的规定，当然不行 就算是 v-moudle 的双向绑定，其实也是封装的传方法和监控，然后子组件调父组件方法完成两边同步 所以说还是应该正常完成子组件传父组件数据的过程，在父组件定义函数操纵自己的变量，然后子组件defineEmits暴露，子组件使用此传参，完成子传父 4、踩坑之支付宝不支持事件委托，因为它魔改了 DOM坑起因是我想实现组件点击计数，点击到5次没有交互的位置，就默认做点什么；如果点击的是有交互的地方，就不干什么，不能给每个东西都绑点击函数吧，所以我想到了事件委托，给根组件绑一个函数就完事了 结果发现是，做不到，点击的对象上怎么啥方法都没有，常用的e.target.closest()直接找不到函数 绑定在 dom 上的函数，形参e，然后我打印了一下e，发现确实没法了，他们给 dom 改完了 比如说有个简单的结构如下 123456789&lt;view class=&quot;wai&quot; onTap=&quot;onTapTest&quot; data-wai=&quot;wai&quot; id=&quot;wai&quot;&gt; 456 &lt;view class=&quot;nei&quot; data-nei=&quot;nei&quot; id=&quot;nei&quot; &gt; 123 &lt;view class=&quot;neinei&quot; data-nei=&quot;neinei&quot; id=&quot;neinei&quot;&gt; 000 &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123onTapTest(e)&#123; console.log(e);&#125; 然后打印结果很令人难受，说明这个 dom 里是啥都没有，对比浏览器的 dom 就这么点东西 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//点击最外面的打印&#123; &quot;currentTarget&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;wai&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 94, &quot;tagName&quot;: &quot;view&quot; &#125;, &quot;detail&quot;: &#123; &quot;clientX&quot;: 70, &quot;clientY&quot;: 263, &quot;pageX&quot;: 70, &quot;pageY&quot;: 263 &#125;, &quot;target&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;wai&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 94, &quot;tagName&quot;: &quot;view&quot;, &quot;targetDataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125; &#125;, &quot;timeStamp&quot;: 1700819502522, &quot;type&quot;: &quot;tap&quot;, &quot;mark&quot;: &#123;&#125;&#125;// 点击中间的打印&#123; &quot;currentTarget&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;wai&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 94, &quot;tagName&quot;: &quot;view&quot; &#125;, &quot;detail&quot;: &#123; &quot;clientX&quot;: 80, &quot;clientY&quot;: 156, &quot;pageX&quot;: 80, &quot;pageY&quot;: 156 &#125;, &quot;target&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;nei&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 113, &quot;tagName&quot;: &quot;view&quot;, &quot;targetDataset&quot;: &#123; &quot;nei&quot;: &quot;nei&quot; &#125; &#125;, &quot;timeStamp&quot;: 1700819522863, &quot;type&quot;: &quot;tap&quot;, &quot;mark&quot;: &#123;&#125;&#125;// 点击最中间的打印&#123; &quot;currentTarget&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;wai&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 94, &quot;tagName&quot;: &quot;view&quot; &#125;, &quot;detail&quot;: &#123; &quot;clientX&quot;: 28, &quot;clientY&quot;: 153, &quot;pageX&quot;: 28, &quot;pageY&quot;: 153 &#125;, &quot;target&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;neinei&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 132, &quot;tagName&quot;: &quot;view&quot;, &quot;targetDataset&quot;: &#123; &quot;nei&quot;: &quot;neinei&quot; &#125; &#125;, &quot;timeStamp&quot;: 1700819539734, &quot;type&quot;: &quot;tap&quot;, &quot;mark&quot;: &#123;&#125;&#125; 解决根据打印出来的东西来看，冒泡还在，currentTarget始终指向绑定事件的最外层元素，target指向实际被点击的元素，且携带着各自的dataset信息。 但是确实鼠标点击事件的target全改了，各种方法没有了，没法拦截点击到最外层，事件委托算基本用不了了 当时我要做的是组件点击计数，点击到5次没有交互的位置，就默认做点什么；如果点击的是有交互的地方，就不干什么 笨方法，写个全局变量，直接给所有交互组件都绑个函数，点击变量置0；给最根组件也绑个函数，点击变++。然后变量监听，到了5就触发某函数 非常笨的方法了，反正是实现了 5、踩坑之单页面组件渲染坑uni路由跳转的话，其实是切换了页面。我想不出现那个页面转换的动画，想让它感觉是直接刷新的 但是uniapp没vue的router路由管理，所以我只能用手动用条件渲染切换组件的方式进行 1&lt;component :is=&quot;...&quot;&gt;&lt;/component&gt; 然后发现is条件渲染也不支持。。。 解决组件用v-if得了。。。 123&lt;component1 v-if=&quot;condition&quot;&gt;&lt;/component1&gt;&lt;component2 v-if=&quot;condition&quot;&gt;&lt;/component2&gt;&lt;component3 v-if=&quot;condition&quot;&gt;&lt;/component3&gt; 6、踩坑之支付宝小程序插件，uniapp里没法给组件导入，只能给页面引入坑结合上一条，我想在组件里引入支付宝小程序的插件，实现页面里面的调用，无缝刷新 但是发现支付宝小程序原生插件引入不了组件里 解决没法了，不给组件引入了，直接给页面引入 本来只管路由组件切换的页面，这下写了一堆东西，调用插件的逻辑全写里面了，真没法","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"小程序","slug":"web前端/小程序","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.me/tags/vue/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.me/tags/TypeScript/"},{"name":"小程序","slug":"小程序","permalink":"http://wishao.me/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"支付宝小程序","slug":"支付宝小程序","permalink":"http://wishao.me/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"彻底关闭Windows Defender","slug":"彻底关闭windows10-Defender","date":"2023-08-03T03:43:37.000Z","updated":"2023-08-03T04:40:50.000Z","comments":true,"path":"2023/08/03/彻底关闭windows10-Defender/","link":"","permalink":"http://wishao.me/2023/08/03/%E5%BD%BB%E5%BA%95%E5%85%B3%E9%97%ADwindows10-Defender/","excerpt":"又一次被Windows Defender气昏，图吧工具箱前脚刚解压完就无声给我删了，有的学习版游戏更是安装完就把执行程序无声干掉了。受不了了，Defender和我必须死一个 目前23年8月3日，Windows10 21H2 19044.3086亲测有效","text":"又一次被Windows Defender气昏，图吧工具箱前脚刚解压完就无声给我删了，有的学习版游戏更是安装完就把执行程序无声干掉了。受不了了，Defender和我必须死一个 目前23年8月3日，Windows10 21H2 19044.3086亲测有效 起因在不知道多少次被Windows Defender自动无声误删之后，终于受不了了。 但是在设置里手动关闭的话，重启电脑它会自动再次开启，网上找到的策略组里关闭方法都不管用了，重启电脑都会再打开，微软为了不让我们把它关了真是处心积虑。 幸亏那个关闭小工具还是有用的，网上搜的各种关闭方法鱼龙混杂，索性自己记录下 步骤1. 首先手动关闭windows Defender防病毒打开设置–&gt;更新和安全–&gt;左侧边栏Windows安全中心–&gt;病毒和威胁防护–&gt;”病毒和威胁防护”设置的管理设置 里面有个实施保护，给他关了 这么做只能临时关，重启电脑就又回来了。不过无所谓，临时关是为了用后面的工具，微软给那个工具重点标记了，不关的话一检测到就给你删了 2. 下载工具蓝奏云 密码:c9xo 下载完解压，解压密码2222 3. 使用双击.exe打开，这是有大神汉化了的，点停用就行了 碎碎念其实可以给误删东西加白名单，就不会删了。自己没点判断力的还是建议别给电脑裸奔，有这么个防护的至少有点用 但是我还是要说了，妈的微软为啥不能给个关这种东西的自由，我就是不想用，必须给他关了","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"http://wishao.me/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"Windows调教","slug":"瞎折腾/Windows调教","permalink":"http://wishao.me/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/Windows%E8%B0%83%E6%95%99/"}],"tags":[{"name":"Windows10","slug":"Windows10","permalink":"http://wishao.me/tags/Windows10/"},{"name":"Windows11，Defender","slug":"Windows11，Defender","permalink":"http://wishao.me/tags/Windows11%EF%BC%8CDefender/"},{"name":"关闭","slug":"关闭","permalink":"http://wishao.me/tags/%E5%85%B3%E9%97%AD/"},{"name":"小软件","slug":"小软件","permalink":"http://wishao.me/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"}]},{"title":"初识canvas","slug":"初识canvas","date":"2023-07-21T11:44:02.000Z","updated":"2023-07-21T12:25:16.000Z","comments":true,"path":"2023/07/21/初识canvas/","link":"","permalink":"http://wishao.me/2023/07/21/%E5%88%9D%E8%AF%86canvas/","excerpt":"为了还原小时候玩过的一个flash游戏，决定学点html5游戏制作。找了个外网教程，先从canvas元素开始","text":"为了还原小时候玩过的一个flash游戏，决定学点html5游戏制作。找了个外网教程，先从canvas元素开始 教程原地址JavaScript Game Development Course for Beginners - YouTube canvas1. 从精灵图动画开始首先在html里引入canvas标签。然后在js中获取其DOM 然后获取canvas上的所有方法。 1const ctx = canvas.getContext(&#x27;2d&#x27;); 这里的参数代表canvas的属性，2d是2d画布。还有别的，可以做3d的东西 下面这么写可以清除画布内容，前面两个参数是要清除的左上角起始点，后面是宽高，表示清除一个矩形 1ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT) 创建一个存精灵图的对象 1const playerImage = new Image(); 图片的传法，第一个是图片，2 3是图片起始点（左上角），4 5是图片拉伸大小 12345ctx.drawImage(playerImage, 0, 0, 6000, 6000);// 还有九个参数的版本，sx sy是图片剪裁起始点，sw sh是剪裁长宽// dx dy是图片放置位置起始点，dw dh是图片放置长宽ctx.drawImage(playerImage, sx, sy, sw, sh, dx, dy, dw, dh); 创建一个帧，使用(其中animate传一个函数，可以放包含上面东西的，操纵canvas) 1requestAnimationFrame(animate); 我们可以在animate里使用此函数调用animate函数自己，就能实现一直创建帧。 在控制canvas的函数的参数里使用变量，并且让他们变化，就能实现基础的动画","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"html5游戏","slug":"web前端/html5游戏","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/html5%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"自学","slug":"自学","permalink":"http://wishao.me/tags/%E8%87%AA%E5%AD%A6/"},{"name":"canvas","slug":"canvas","permalink":"http://wishao.me/tags/canvas/"},{"name":"游戏","slug":"游戏","permalink":"http://wishao.me/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"TypeScript入门","slug":"TypeScript入门","date":"2023-07-15T12:08:27.000Z","updated":"2023-07-24T09:50:49.000Z","comments":true,"path":"2023/07/15/TypeScript入门/","link":"","permalink":"http://wishao.me/2023/07/15/TypeScript%E5%85%A5%E9%97%A8/","excerpt":"TypeScript 基础再次学习","text":"TypeScript 基础再次学习 TypeScript 基础知识1, 安装使用全局安装 1npm i -g TypeScript 初始化文件夹配置文件 1tsc --init 一般使用，直接输入tsc，就自动把 ts 编译成 js 为了方便，可以监听变化，保存就自动编译 1tsc --watch 2. 基础类型TypeScript 提供了 JavaScript 中所有的基础数据类型，如： boolean number string array tuple enum any void null and undefined never ts 允许我们显示标注类型，或者不标也行，可以隐式推断 1234567891011121314151617181920212223242526272829let isDone: boolean = false;let decimal: number = 6;let color: string = &#x27;blue&#x27;;let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3]; // 用Array对象定义数组let x: [string, number]; // 这是元组x = [&#x27;hello&#x27;, 10];enum Color &#123; Red, Green, Blue,&#125;let c: Color = Color.Green;let notSure: any = 4;notSure = &#x27;maybe a string instead&#x27;;notSure = false;function warnUser(): void &#123; console.log(&#x27;This is my warning message&#x27;);&#125;let unusable: void = undefined;let u: undefined = undefined;let n: null = null; 3. 联合类型TypeScript 的一大特性是能够明确指定一个值可能的类型范围。 1234let value: number | string;value = &#x27;hello&#x27;; // Okvalue = 100; // Okvalue = true; // Error: boolean is not assignable to type &#x27;string | number&#x27; 4. 类型断言类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。主要是因为 ts 的类型检查只能在编译时进行，编译后会抹去类型，变成普通的 js 代码 123let someValue: any = &#x27;this is a string&#x27;;let strLength: number = (&lt;string&gt;someValue).length; // 前置尖括号断言let strLength: number = (someValue as string).length; // as断言，两种都可以 5. 元组和枚举元组类型允许表现一个已知元素数量和类型的数组，各元素的类型不必相同。 1234let tupleType: [string, number];tupleType = [&#x27;hello&#x27;, 10];console.log(tupleType[0].substring(1)); // OKconsole.log(tupleType[1].substring(1)); // Error 枚举是一种特殊的类型，它可以包含一组命名的常量。枚举可以是数字枚举，字符串枚举，异构枚举。 12345678910111213enum Color &#123; Red, Green, Blue,&#125; // numeric enumlet c: Color = Color.Green;enum Direction &#123; Up = &#x27;UP&#x27;, Down = &#x27;DOWN&#x27;, Left = &#x27;LEFT&#x27;, Right = &#x27;RIGHT&#x27;,&#125; // string enum 6. 接口接口在 TypeScript 中是一个重要的概念，它是对行为的抽象，也是鸭子类型的一种表现。 鸭子类型 - 维基百科 12345678910interface LabelledValue &#123; label: string;&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123; size: 10, label: &#x27;Size 10 Object&#x27; &#125;;printLabel(myObj); （简单来说就是，如果你定义了一个接口的结构，然后造了个对象有这个接口一模一样的属性，就算是造这个对象的时候没直接用 implement，TypeScript 也会认为这个对象是这个接口的实现，可以传入某个接受这个接口类型的函数当参数，不会报错） 7. 泛型泛型就是解决类、接口、方法的复用性，以及对不特定数据类型的支持。 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let output = identity&lt;string&gt;(&#x27;myString&#x27;); // type of output will be &#x27;string&#x27;s 8. 装饰器与反射元数据8.1 装饰器装饰器，顾名思义，可以添加一些附加功能在代码中。在 TypeScript 中，装饰器提供了一种方法，能在运行时修改类的行为或对类进行额外的处理。它们可以应用在类，方法，属性或者参数等多个地方。这是一个很强大的功能，允许对类的行为进行扩展，而无需改变类的定义。 装饰器有四种类型： 类装饰器 属性装饰器 方法装饰器 参数装饰器 12345678910111213141516// 类装饰器function sealed(constructor: Function) &#123; Object.seal(constructor); Object.seal(constructor.prototype);&#125;@sealedclass Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return &#x27;Hello, &#x27; + this.greeting; &#125;&#125; 在这个例子中，@sealed装饰器会在运行时应用到Greeter类上，导致无法向Greeter类添加新的属性，并且已有的属性无法删除或配置。 8.2 反射元数据反射元数据是一种在设计阶段添加和读取元数据的方式。反射 API 包含很多功能，如查询类，接口，参数和返回类型等的设计类型。这为库作者提供了一种检查类结构的强大工具。 在 TypeScript 中使用反射元数据，需要使用reflect-metadata库，并在 tsconfig.json 文件中开启emitDecoratorMetadata选项。 这是一个基础的反射元数据使用例子： 1234567891011121314151617181920import &#x27;reflect-metadata&#x27;;class MyClass &#123; @validate public someMethod(someArg: any) &#123; // Do something &#125;&#125;function validate(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;any&gt;) &#123; let originalMethod = descriptor.value; descriptor.value = function (...args: any[]) &#123; let metadataValue = Reflect.getMetadata(&#x27;design:paramtypes&#x27;, target, propertyKey); if (metadataValue !== someArg) &#123; throw new Error(`Validation failed on argument $&#123;someArg&#125;`); &#125; return originalMethod.apply(this, args); &#125;; return descriptor;&#125; 在这个例子中，validate装饰器使用反射 API 来获取someMethod方法参数的设计类型，并检查是否和方法被调用时传入的参数类型一致。如果不一致，就抛出一个错误。 练习1. 封装 fetch，实现简单 axios 功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// 4种请求方法type Method = &#x27;GET&#x27; | &#x27;POST&#x27; | &#x27;PUT&#x27; | &#x27;DELETE&#x27;;// 请求配置interface RequestConfig &#123; url: string; method?: Method; body?: Object; headers?: Record&lt;string, string&gt;;&#125;// 类似axios的返回值设置interface AxiosResponse&lt;T = any&gt; &#123; data: T; status: number; statusText: string; headers: Record&lt;string, string&gt;; config: RequestConfig; // 去看了看axios文档，用fetch的话，搞不到axios底层XHR信息，空着算了 request: &#123;&#125;;&#125;class MyAxios &#123; // 添加请求和响应拦截器数组 requestInterceptors: Array&lt;(config: RequestConfig) =&gt; RequestConfig&gt; = []; responseInterceptors: Array&lt;(response: AxiosResponse&lt;any&gt;) =&gt; AxiosResponse&lt;any&gt;&gt; = []; // 在发送请求前可以添加请求拦截器 useRequestInterceptor(interceptor: (config: RequestConfig) =&gt; RequestConfig): void &#123; this.requestInterceptors.push(interceptor); &#125; // 在收到响应后可以添加响应拦截器 useResponseInterceptor(interceptor: (response: AxiosResponse&lt;any&gt;) =&gt; AxiosResponse&lt;any&gt;): void &#123; this.responseInterceptors.push(interceptor); &#125; // fetch请求调用 private async request&lt;T = any&gt;(config: RequestConfig, method: Method): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; // 请求拦截器 this.requestInterceptors.forEach((interceptor) =&gt; &#123; config = interceptor(config); &#125;); const res: Response = await fetch(config.url, &#123; method, body: config.body ? JSON.stringify(config.body) : undefined, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, ...config.headers, &#125;, &#125;); // 处理fetch的返回值让它更像axios的返回值 if (!res.ok) &#123; throw new Error(`$&#123;res.status&#125; $&#123;res.statusText&#125;`); &#125; const data: T = await res.json(); // status和statusText一样，就不用单独处理，后面直接赋值 const headers: Record&lt;string, string&gt; = &#123;&#125;; res.headers.forEach((value: string, key: string) =&gt; &#123; headers[key] = value; &#125;); let axiosResponse: AxiosResponse&lt;T&gt; = &#123; data, status: res.status, statusText: res.statusText, headers, config, // 只能空着了 request: &#123;&#125;, &#125;; // 响应拦截器 this.responseInterceptors.forEach((interceptor) =&gt; &#123; axiosResponse = interceptor(axiosResponse); &#125;); return axiosResponse; &#125; // get请求，由于可以传config或者直接传url，所以重载了一下 async get&lt;T = any&gt;(url: string): Promise&lt;AxiosResponse&lt;T&gt;&gt;; async get&lt;T = any&gt;(config: RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt;; async get&lt;T = any&gt;(url_or_config: string | RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; let config: RequestConfig; if (typeof url_or_config === &#x27;string&#x27;) &#123; config = &#123; url: url_or_config &#125;; &#125; else &#123; config = url_or_config; &#125; return await this.request&lt;T&gt;(config, &#x27;GET&#x27;); &#125; // post请求 async post&lt;T = any&gt;(config: RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; return await this.request&lt;T&gt;(config, &#x27;POST&#x27;); &#125; // put请求 async put&lt;T = any&gt;(config: RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; return await this.request&lt;T&gt;(config, &#x27;PUT&#x27;); &#125; // delete请求 async delete&lt;T = any&gt;(config: RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; return await this.request&lt;T&gt;(config, &#x27;DELETE&#x27;); &#125;&#125;const myAxios: MyAxios = new MyAxios();// 测试get// 添加请求拦截器，添加统一的请求头myAxios.useRequestInterceptor((config: RequestConfig) =&gt; &#123; config.headers = &#123; ...config.headers, &#x27;X-My-Custom-Header&#x27;: &#x27;CustomHeaderValue&#x27;, &#125;; return config;&#125;);// 添加响应拦截器，对响应数据进行一些处理myAxios.useResponseInterceptor((response: AxiosResponse&lt;any&gt;) =&gt; &#123; // 对响应数据进行处理，这里只是简单的加了一个字段 response.data = &#123; ...response.data, fromInterceptor: &#x27;来自响应拦截器，这是ツユ的歌曲列表:&#x27;, &#125;; return response;&#125;);// 发送请求，查看拦截器是否生效myAxios.get(&#x27;http://162.14.111.196:4000/artist/songs?id=34505358&#x27;).then((res: AxiosResponse) =&gt; &#123; console.log(&#x27;测试get\\n&#x27;); console.log(res); console.log(res.data.fromInterceptor + &#x27;\\n&#x27;); res.data.songs.forEach((song: any) =&gt; &#123; console.log(song.al.name); if (song.tns) &#123; console.log(song.tns[0]); &#125; console.log(); &#125;);&#125;); 2. 类型体操之 DeepReadonly123456789101112131415161718type X = &#123; x: &#123; a: 1; b: &#x27;hi&#x27;; c: &#123; d: true; e: &#x27;false&#x27;; f: 3; &#125;; &#125;; y: &#x27;hey&#x27;;&#125;;type DeepReadonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] extends object ? DeepReadonly&lt;T[P]&gt; : T[P];&#125;;type Todo = DeepReadonly&lt;X&gt;;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"TypeScript学习","slug":"web前端/TypeScript学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/TypeScript%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.me/tags/TypeScript/"},{"name":"笔记，手写还原","slug":"笔记，手写还原","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0%EF%BC%8C%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"}]},{"title":"react入门","slug":"react入门","date":"2023-07-14T13:45:29.000Z","updated":"2023-07-24T09:50:41.000Z","comments":true,"path":"2023/07/14/react入门/","link":"","permalink":"http://wishao.me/2023/07/14/react%E5%85%A5%E9%97%A8/","excerpt":"进行一个 react 的速通","text":"进行一个 react 的速通 1. 建立项目建议用 vite 搭建，很快 1npm create vite@latest 然后选 react 模板 2. JSXJSX (JavaScipt XML) 就是 react 中的 HTML，通过 js 的自身可编程能力来创建 HTML 结构 将命令式写法简化为声明式写法 3. 函数式组件新 react 基本不用 class 组件了，全用函数式组件。它们的各种东西也受影响，想做函数式编程 函数式组件例如: 1234567891011function Hello() &#123; return &lt;div style=&#123;&#123; color: &#x27;red&#x27; &#125;&#125;&gt;Hello World!&lt;/div&gt;;&#125;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;Hello&gt;&lt;/Hello&gt; &lt;/div&gt; );&#125; 注意函数名首字母大写，return 的也只能有一个根组件 4. 组件通信父传子父组件提供需要传递的数据 state给子组件标签添加属性值为 state 中的数据函数式子组件直接通过参数获取 props 对象，接收父组件中传过来的值 子传父本质是子组件调用父组件传递的函数，并将想要传递的数据当成函数的实参 5. hooks为了拥抱函数式编程所做的东西。因为真正的函数式编程不允许函数有副作用，但是这是前端，组件不可避免的需要有储存信息，交互其他东西的功能，就引入了 hooks 来做这些事，假装自己还是函数式编程。 Hook 就是 Javascript 函数，但是只能在函数外层调用 Hook，不要在循环、条件判断或者子函数中调用；只能在 React 的函数组件和自定义 Hook 中调用 Hook。不要在其他 JavaScript 函数中调用 useStateuseState 是一个函数，它接受初始状态作为参数，并返回一个包含两个元素的数组：当前状态和一个用于更新状态的函数。比如： 1const [count, setCount] = useState(0); 在这个例子中，count 是当前的状态（初始值为 0），而 setCount 是一个函数，可以用于更新 count 的值。 useEffectuseEffect 允许在函数组件中执行副作用操作。它接受一个函数（通常称之为“effect”）作为参数。可以在 effect 中执行任何副作用操作，例如数据获取、订阅或手动修改 DOM。useEffect 还可以返回一个函数，该函数将在组件卸载前或更新前执行，可以在这个函数中执行任何清理操作。 1234567useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; return () =&gt; &#123; // cleanup logic goes here &#125;;&#125;, [count]); // 仅在 count 更改时更新 useRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 123const inputRef = useRef(null);// you can access its current value like thisconsole.log(inputRef.current); useContextuseContext 接受一个上下文对象（React.createContext 的返回值）并返回该上下文的当前值。当前的上下文值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 123const ThemeContext = React.createContext(&#x27;light&#x27;);const theme = useContext(ThemeContext);console.log(theme); // &quot;light&quot; useReduceruseReducer 是一个替代 useState 的 Hook，它接受一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的状态以及与其配套的 dispatch 方法。 1234567891011121314151617181920212223const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123; count: state.count + 1 &#125;; case &#x27;decrement&#x27;: return &#123; count: state.count - 1 &#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"react学习","slug":"web前端/react学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/react%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"自学","slug":"自学","permalink":"http://wishao.me/tags/%E8%87%AA%E5%AD%A6/"},{"name":"react","slug":"react","permalink":"http://wishao.me/tags/react/"}]},{"title":"Vue响应式原理","slug":"Vue响应式原理","date":"2023-07-13T07:55:35.000Z","updated":"2023-07-24T09:50:32.000Z","comments":true,"path":"2023/07/13/Vue响应式原理/","link":"","permalink":"http://wishao.me/2023/07/13/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"为了深入理解 vue 的响应式数据，手写还原 ref、reactive、computed","text":"为了深入理解 vue 的响应式数据，手写还原 ref、reactive、computed 前置知识见 JavaScript 现代教程。基于映射，集合与代理完成响应式数据 Map 和 SetProxy 和 Reflectreactive比较复杂，考虑到会有多个响应式对象，每个对象有多个属性，每个属性有多个影响它的函数，所以用三级结构储存最顶部是是个 WeakMap，存储的是那多个响应式对象，每个对象对应一个 Map，存储的是这个对象的多个属性，每个属性对应一个 Set，存储的是影响这个属性的多个函数然后用 proxy 代理，当读取属性时，触发收集依赖，当设置属性时，触发更新。同时由于没有给影响函数命名，所以设置了一个数组当堆栈储存影响函数，应对同时注册多个函数的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 使用 WeakMap 来存储每个对象的依赖关系const targetMap = new WeakMap();// 当前活动的 effect 函数，默认为 nulllet activeEffect = null;// 用一个数组来实现堆栈，存储所有的 effect 函数let activeEffectStack = [];// effect 函数用于设置当前的活动 effectfunction effect(eff) &#123; try &#123; // 把 eff 函数添加到堆栈中，并设为当前活动的 effect activeEffectStack.push(eff); activeEffect = eff; // 立即执行 eff 函数 eff(); &#125; finally &#123; // 执行完 eff 函数后，把它从堆栈中移除，并恢复之前的活动 effect activeEffectStack.pop(); activeEffect = activeEffectStack[activeEffectStack.length - 1]; &#125;&#125;// track 函数用于设置对象属性的依赖function track(target, key) &#123; // 只有当有活动的 effect 时才进行依赖收集 if (activeEffect) &#123; let depsMap = targetMap.get(target); if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if (!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(activeEffect); &#125;&#125;// trigger 函数用于触发对象属性的更新function trigger(target, key) &#123; const depsMap = targetMap.get(target); if (depsMap) &#123; const dep = depsMap.get(key); if (dep) &#123; dep.forEach((eff) =&gt; &#123; eff(); &#125;); &#125; &#125;&#125;// reactive 函数用于创建一个响应式的对象，使用了proxy拦截修改或者读取function reactive(target) &#123; return new Proxy(target, &#123; get(target, key, receiver) &#123; // 使用Reflect，直接能调用这些隐藏的底层方法 const result = Reflect.get(target, key, receiver); track(target, key); return result; &#125;, set(target, key, value, receiver) &#123; const oldValue = Reflect.get(target, key, receiver); const result = Reflect.set(target, key, value, receiver); if (oldValue !== value) &#123; trigger(target, key); &#125; return result; &#125;, &#125;);&#125;// 测试代码let product = reactive(&#123; price: 10, quantity: 2 &#125;);let total = 0, salePrice = 0;effect(() =&gt; &#123; total = product.price * product.quantity;&#125;);effect(() =&gt; &#123; salePrice = product.price * 0.9;&#125;);console.log(total, salePrice); // 20 9product.quantity = 5;console.log(total, salePrice); // 50 9product.price = 20;console.log(total, salePrice); // 100 18 捋顺一下此测试代码的执行过程: 创建响应式对象 首先调用reactive传入我们要变成响应式的对象&#123; price: 10, quantity: 2 &#125;，返回一个经过 proxy 代理的对象，命名为product。 设置第一个影响函数 然后使用effect设置影响函数。effect内部会先给传入的影响函数加入堆栈顶，然后执行一次此函数。执行过程中涉及到了product.price * product.quantity，也就是说读取了product，被 proxy 的 get 拦截到。 proxy 的 get 里使用product和它的值.price调用track，在三级储存结构里逐层注册。最后一层 Set 里注册了堆栈顶的那个才传入的影响函数。同时product.quantity也干了一样的事，不过第一层已经有product了，就在product下第二层注册.quantity，也给它加上了那个影响函数。 结束track，使用 Reflect 的 get 再获取一下product.price，返回。 终于结束了调用这次影响函数，这个影响函数也从堆栈顶弹出。 设置第二个影响函数 然后就是注册了第二个影响函数，也做了类似的一套流程，为price多加了个影响函数。 打印初始值 console.log部分，没啥说的，就是打印俩普通值。它们在注册影响函数的时候，因为那次立即执行，获得了数据。 修改 product.quantity 随后是改变product.quantity的值为 5，被 proxy 的 set 拦截到，确认是更改，使用product和.quantity属性调用了更新器trigger。更新器在三级储存结构里找到这个对象和属性，执行一次.quantity所有注册在 Set 里的影响函数。它只注册了第一个影响函数，就执行，重新计算了total的值。打印，发现了total的变化。 修改 product.price 下面改变price同理，proxy 的 set 拦截，调用触发器，执行price下面的俩影响函数，再次打印输出就看见俩个值都变了。 ref因为每次的更新都需要调用.value，所以 ref 比较简单，只需要用 value 的 get set 就能实现自动更新，不需要像实现 reactive 那样使用 proxy 代理来拦截读取或写入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 使用 WeakMap 来存储每个对象的依赖关系const targetMap = new WeakMap();// 当前活动的 effect 函数，默认为 nulllet activeEffect = null;// 用一个数组来实现堆栈，存储所有的 effect 函数let activeEffectStack = [];// effect 函数用于设置当前的活动 effectfunction effect(eff) &#123; try &#123; // 把 eff 函数添加到堆栈中，并设为当前活动的 effect activeEffectStack.push(eff); activeEffect = eff; // 立即执行 eff 函数 eff(); &#125; finally &#123; // 执行完 eff 函数后，把它从堆栈中移除，并恢复之前的活动 effect activeEffectStack.pop(); activeEffect = activeEffectStack[activeEffectStack.length - 1]; &#125;&#125;// track 函数用于设置对象属性的依赖function track(target, key) &#123; // 只有当有活动的 effect 时才进行依赖收集 if (activeEffect) &#123; let depsMap = targetMap.get(target); if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if (!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(activeEffect); &#125;&#125;// trigger 函数用于触发对象属性的更新function trigger(target, key) &#123; const depsMap = targetMap.get(target); if (depsMap) &#123; const dep = depsMap.get(key); if (dep) &#123; dep.forEach((effect) =&gt; &#123; effect(); &#125;); &#125; &#125;&#125;// ref 函数用于创建一个可响应的对象function ref(raw) &#123; const r = &#123; _is_ref: true, // 添加一个标记，表示这是一个 ref 对象 _value: raw, // 存储原始值 // 当访问 value 属性时，进行依赖收集 get value() &#123; track(r, &#x27;value&#x27;); return this._value; &#125;, // 当设置 value 属性时，触发更新 set value(newVal) &#123; this._value = newVal; trigger(r, &#x27;value&#x27;); &#125;, &#125;; return r;&#125;const count = ref(0);console.log(count.value); // 0// 创建一个 effect，监听 count 的变化effect(() =&gt; &#123; console.log(`count的值是: $&#123;count.value&#125;`);&#125;);// 改变 count.value，触发更新count.value++; computed调用了之前完成的 ref 完成 12345678910111213141516171819202122// 前面就是上面ref和reactive的代码// computed 函数用于创建一个计算属性function computed(getter) &#123; const result = ref(); effect(() =&gt; (result.value = getter())); return result;&#125;let product = reactive(&#123; price: 10, quantity: 2 &#125;);let salePrice = computed(() =&gt; &#123; return product.price * 0.9;&#125;);let total = computed(() =&gt; &#123; return salePrice.value * product.quantity;&#125;);console.log(total.value, salePrice.value); // 18, 9product.quantity = 5;console.log(total.value, salePrice.value); // 45, 9product.price = 20;console.log(total.value, salePrice.value); // 90, 18 computed 函数结合了这两个函数的功能。首先用 ref 创建了一个响应式数据 result，然后用 effect 创建了一个副作用，这个副作用的作用就是计算传入的 getter 函数，并把结果赋值给 result.value。所以当 getter 函数内部使用的任何响应式数据发生变化时，getter 函数就会被重新计算，result.value 也会被更新。最后，computed 函数返回这个 result，也是个响应式的（ref）。外部代码可以通过读取 result.value 来获取计算的结果，也可以通过观察 result.value 的变化来响应这个计算结果的变化。 感悟手写实现确实能深入理解代码。。。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.me/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"},{"name":"vue","slug":"vue","permalink":"http://wishao.me/tags/vue/"}]},{"title":"前端零碎拾遗","slug":"前端零碎拾遗","date":"2023-07-12T13:45:00.000Z","updated":"2023-11-18T15:35:55.000Z","comments":true,"path":"2023/07/12/前端零碎拾遗/","link":"","permalink":"http://wishao.me/2023/07/12/%E5%89%8D%E7%AB%AF%E9%9B%B6%E7%A2%8E%E6%8B%BE%E9%81%97/","excerpt":"汇总下写着写着突然又想起来或者才听说的东西","text":"汇总下写着写着突然又想起来或者才听说的东西 html经常忘的标签 &lt;hr/&gt;横线 emmet 语法 TAB 键+标签名快速生成标签 div*4 生成 4 个 div ul&gt;li 快速生成包含关系 div+p 快速生成兄弟关系 span.nar 快速标签内类名 .aad$*5快速依次生成5个aad类名(无$就生一样的) div{东西} css去下划线text-decoration: none; 去输入框点击时边框outline:none; :root这个伪类表示 html 标签，而且比他等级更高，是 dom 树里根中之根，可以存点变量啥的 var()函数可以调用存在父节点里的变量 主义变量命名要以两个横杠–开头 居中更多技巧1. 定位时用负边距居中这个需要已知元素大小 比如说定位是left: 50%，元素100px宽那可以设置margin-left: -50px实现居中 2. 定位和 transform 居中这个不需要元素大小，可以对动态的元素设置 设置父元素position: relative，随后对子元素设置 1234position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%); 3. 定位和 flex 同时使用，让多元素重叠居中这个可能不常用，但确实来源于我一个真实需求 比如说这是个天气信息展示，需要在一行内同一个地方展示风力和湿度。看起来就是一行字待 2 秒，然后向上移动渐变消失，同时另一行字从下面渐变向上出现移动到同一位置，如此循环展示。 难点是风力和湿度字数不定，所以就没办法让它固定宽度。而且初始位置是重叠的，并且动画已经占用了transform，上面方案二用不了了，有点难弄 1234&lt;div class=&quot;humidity-wind&quot;&gt; &lt;div class=&quot;humidity&quot;&gt;湿度 45%&lt;/div&gt; &lt;div class=&quot;wind&quot;&gt;东南风 1级&lt;/div&gt;&lt;/div&gt; 我是这么写的 css 123456789101112131415161718192021222324252627282930313233343536373839404142.humidity-wind &#123; height: 2vh; width: 100vw; position: relative; /* 使风向和湿度居中，我去居然能这么写，医学奇迹啊 */ display: flex; justify-content: center;&#125;.humidity-wind &gt; .humidity,.humidity-wind &gt; .wind &#123; position: absolute; animation: scroll-up 10s linear infinite; white-space: nowrap;&#125;.humidity-wind &gt; .wind &#123; opacity: 0; transform: translateY(100%); animation-delay: 5s; /* 风向动画延迟，确保湿度消失后开始 */&#125;@keyframes scroll-up &#123; 0% &#123; transform: translateY(100%); opacity: 0; &#125; 5% &#123; transform: translateY(0); opacity: 1; &#125; 50% &#123; transform: translateY(0); opacity: 1; &#125; 55% &#123; transform: translateY(-100%); opacity: 0; &#125; 100% &#123; transform: translateY(-100%); opacity: 0; &#125;&#125; 重点就是这了 12display: flex;justify-content: center; 这些和position: absolute同时使用。可以尝试一下，如果去掉动画的 transform 的话，是两个 div 重叠居中的。 我以前一直以为设了定位就脱标了，flex 不能影响到，没想到啊，是能同时用的 看 GPT4 解释的是，子元素使用了 position: absolute，那么这个子元素会相对于这个容器进行定位，并且也会继承容器的 align-items 和 justify-content 属性 总之很有意思，记一下 JavaScriptJS 读元素 css 属性使用 xxx.style 的方法只能读到内联的 css，外联读出来全是空的 可以用getComputedStyle(elem, [pseudo]) 返回一个对象，包含所有 style。比如： 1234let computedStyle = getComputedStyle(document.body);console.log(computedStyle.marginTop); // 5pxconsole.log(computedStyle.color); // rgb(255, 0, 0) .reduce() 方法arr.reduce(function(accumulator, item, index, array) &#123; // ...&#125;, [initial]); accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。(相当于一个累加器) item —— 当前的数组元素。 index —— 当前索引。 arr —— 数组本身。 .replace 方法str.replace(regexp, replacement) 使用 replacement 替换在字符串 str 中找到的 regexp 的匹配项（如果带有修饰符 g 则替换所有匹配项，否则只替换第一个） .split 方法str.split(分隔符) 用以创建一个以分隔符为分割标志的数组 .join 方法arr.join(插入符) 返回一个字符串，这个字符串是由数组所有元素拼成，中间夹着插入符 如果不写就默认用,间隔，让它没有的话得写空字符串&#39;&#39; Array.prototype.slice.call()可将类数组(arguments,NodeList)，字符串(String)转换成数组。 为什么用它呢，因为比如 NodeList 缺像是 map 之类的数组方法，转化就能用了 Object.prototype.toString.call(fn) !&#x3D;&#x3D; ‘[object Function]’判断 fn 是不是函数 动态的居中问题比如说有个框，宽度定死了但是高度没定，你预先不知道有多少内容会给高度撑成多少，怎么上下的居中 可以先用定位，给他设置 top:50%，然后 js 给他负的边框，数值是自己的高度一半（当然是用 js 获取可视高度） xxxx.style.marginTop = &#39;-$&#123;xxxx.offsetHeight / 2&#125;px&#39; 展开运算符的覆写展开操作符...会将一个对象的所有可枚举属性复制到新的对象上。如果在展开操作符之后我们再定义一个与展开对象中同名的属性，那么这个新定义的属性的值将覆盖展开操作符复制过来的同名属性。 比如说 12345const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; ...obj1, b: 3, c: 4 &#125;;console.log(obj2); // 输出 &#123; a: 1, b: 3, c: 4 &#125; Object.entries() 方法Object.entries(要处理的对象) 接收一个对象作为参数，并返回一个数组。这个数组的每个元素都是另一个数组，其中包含对象中每个属性的键和值。如果传入的是一个空对象或没有属性的对象，它会返回一个空数组。 例如，假设有一个对象 obj = &#123; a: 1, b: 2 &#125;，那么 Object.entries(obj) 会返回 [[&#39;a&#39;, 1], [&#39;b&#39;, 2]]。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"拾遗","slug":"拾遗","permalink":"http://wishao.me/tags/%E6%8B%BE%E9%81%97/"}]},{"title":"Redux状态管理","slug":"Redux状态管理","date":"2023-07-12T13:36:33.000Z","updated":"2023-07-15T13:39:17.000Z","comments":true,"path":"2023/07/12/Redux状态管理/","link":"","permalink":"http://wishao.me/2023/07/12/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","excerpt":"为了深入理解 Redux 状态管理工具，手写一个简化的（也是作业）","text":"为了深入理解 Redux 状态管理工具，手写一个简化的（也是作业） 手写一个类似 Redux 的 createStore，实现一个简单的列表增删。 输入名称，序号自增并以此名称添加进列表；输入要删除的序号，就删除对应序号的行 index.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;redux&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;add&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入名称&quot; /&gt; &lt;button&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;delete&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入要删除的id&quot; /&gt; &lt;button&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;show&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const addTextDOM = document.querySelector(&#x27;.add input&#x27;);const addBtnDOM = document.querySelector(&#x27;.add button&#x27;);const deleteTextDOM = document.querySelector(&#x27;.delete input&#x27;);const deleteBtnDOM = document.querySelector(&#x27;.delete button&#x27;);const showDOM = document.querySelector(&#x27;.show&#x27;);// 手写简单Reduxfunction createStore(reducer) &#123; // 闭包内数据，一个是所存数据，一个是注册的函数 // 初始化 state let state = reducer(undefined, &#123;&#125;); const listeners = []; // 从闭包里获取state的函数 const getState = () =&gt; state; // 核心，dispatch函数，使用传入的reducer更新state，同时触发所有注册的函数 const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach((listener) =&gt; listener()); &#125;; // 注册函数，返回一个取消注册的函数 const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; const index = listeners.indexOf(listener); listeners.splice(index, 1); &#125;; &#125;; return &#123; getState, dispatch, subscribe &#125;;&#125;// 此例子的reducer，这里state进行了初始化，这样规定了state的数据结构// names数组里面放的是有id和name俩属性的对象function reducer(state = &#123; id: 0, names: [] &#125;, action) &#123; switch (action.type) &#123; case &#x27;ADD&#x27;: return &#123; id: state.id + 1, names: [...state.names, &#123; id: state.id, name: action.name &#125;], &#125;; case &#x27;DELETE&#x27;: return &#123; // 这里重写了展开属性，覆盖了原来的names ...state, names: state.names.filter((item) =&gt; item.id !== action.id), &#125;; default: return state; &#125;&#125;// 利用手写的createStore函数创建storeconst store = createStore(reducer);// 渲染函数function render() &#123; const currentState = store.getState(); // 获取当前的状态 showDOM.innerHTML = currentState.names.map((item) =&gt; `&lt;p&gt;序号:$&#123;item.id&#125;，名称:$&#123;item.name&#125;&lt;/p&gt;`).join(&#x27;&#x27;);&#125;// 注册渲染的函数，同时返回一个取消注册的函数（虽然说没用到吧const unRender = store.subscribe(render);addBtnDOM.addEventListener(&#x27;click&#x27;, () =&gt; &#123; const name = addTextDOM.value; store.dispatch(&#123; type: &#x27;ADD&#x27;, name &#125;); addTextDOM.value = &#x27;&#x27;;&#125;);deleteBtnDOM.addEventListener(&#x27;click&#x27;, () =&gt; &#123; const id = Number(deleteTextDOM.value); store.dispatch(&#123; type: &#x27;DELETE&#x27;, id &#125;); deleteTextDOM.value = &#x27;&#x27;;&#125;);","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.me/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"}]},{"title":"Vue Pinia","slug":"Vue-Pinia","date":"2023-07-12T03:26:14.000Z","updated":"2023-07-24T09:50:13.000Z","comments":true,"path":"2023/07/12/Vue-Pinia/","link":"","permalink":"http://wishao.me/2023/07/12/Vue-Pinia/","excerpt":"Vue 状态管理库 Pinia，非常好用","text":"Vue 状态管理库 Pinia，非常好用 PiniaPinia 是一款轻量级的 Vue 状态管理库，可以使用它跨组件或页面共享状态。 相当于组件的组件，可以用来定义一些共用的东西，也可以用来传递数据。 能用 vue3 的组合式语法来写，与本来的组件完全一致，非常直观好用 1. 引入先安装 1npm i pinia 然后在 main.js 引入 1234import &#123; createPinia &#125; from &#x27;pinia&#x27;;const app = createApp(App);app.use(pinia); 2. 基础使用一般来说，先在 src 文件夹里创建一个 stores 文件夹，专门存放 pinia 组件 比如定义一个计数器的组件，使用了组合式语法，定义一个响应式数据和一个方法 123456789101112131415import &#123; defineStore &#125; from &#x27;pinia&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123; const count = ref(0); const increment = () =&gt; &#123; count.value++; &#125;; return &#123; count, increment, &#125;;&#125;); 步骤是先引入defineStore，使用它定义一个组件供导出使用 然后在 vue 文件里导入useCounterStore，使用变量接收，就能像这样使用了 1234567891011&lt;script setup&gt; import &#123; useCounterStore &#125; from &#x27;./stores/counter&#x27;; const counterStore = useCounterStore(); console.log(counterStore);&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;counterStore.increment&quot;&gt;&#123;&#123; counterStore.count &#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 3. getters 实现使用computed计算属性实现，然后导出，比如 1const doubleCount = computed(() =&gt; count.value * 2); 4. 异步请求比如网络请求 axios，直接在 store 里面写，写完导出，就能直接在引入的地方用了 5. 解构赋值看之前的代码，引入使用的时候每次都要写counterStore.xxx，很啰嗦。 可以使用解构赋值来赋值给变量 123const &#123; count, doubleCount &#125; = storeToRefs(counterStore);// 注意，这个方法只能获取到响应式数据，没法获得方法// 获取方法，比如increment，直接不用这个函数，直接解构赋值就行了（因为是引用值） 注意要用它的storeToRefs方法，不然直接写的话会丢失响应式数据的特性。获取到的是响应式对象","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.me/tags/vue/"},{"name":"自学","slug":"自学","permalink":"http://wishao.me/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"js基础复习","slug":"js基础复习","date":"2023-07-11T12:30:37.000Z","updated":"2023-07-24T09:50:06.000Z","comments":true,"path":"2023/07/11/js基础复习/","link":"","permalink":"http://wishao.me/2023/07/11/js%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","excerpt":"复习原生 js 知识","text":"复习原生 js 知识 1. this 指向问题里的 call apply bindcallcall是一个方法，它的作用是改变函数的this指向。第一个参数是用于替换this的值，后续的参数是传递给函数的参数。例如： 1234567function showName(age, job) &#123; console.log(`My name is $&#123;this.name&#125;, I&#x27;m $&#123;age&#125; years old and I am a $&#123;job&#125;.`);&#125;let person = &#123; name: &#x27;Tom&#x27; &#125;;showName.call(person, 25, &#x27;engineer&#x27;); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. call会立即执行函数。 applyapply方法的作用和call类似，都是用于改变函数的this指向，不过apply接收的参数是一个数组（或类数组对象），第一个参数同样是用于替换this的值，第二个参数是传递给函数的参数数组。例如： 1234let person = &#123; name: &#x27;Tom&#x27; &#125;;let args = [25, &#x27;engineer&#x27;];showName.apply(person, args); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. 和call一样，apply也会立即执行函数。 bindbind方法也是用于改变函数的this指向，它的使用方法和call类似，第一个参数是用于替换this的值，后续的参数是传递给函数的参数。不过，不同于call和apply，bind不会立即执行函数，而是返回一个新的函数。例如： 12345let person = &#123; name: &#x27;Tom&#x27; &#125;;let newShowName = showName.bind(person, 25, &#x27;engineer&#x27;);newShowName(); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. 总结： call和apply的主要作用都是改变函数的this指向，并立即执行函数。它们的区别主要在于参数的传递方式，call是将参数依次传入，而apply则是以数组形式传入参数。 bind方法也可以改变函数的this指向，但不同的是，它会返回一个新的函数，可以在需要的时候再去调用这个新函数。 2. 事件等级DOM 0 级事件DOM 0 级事件又称为原始事件模型，其事件绑定方法非常简单，直接在 HTML 元素上通过事件属性（如 onclick、onload、onmouseover 等）绑定 JavaScript 函数，或者在 JavaScript 代码中通过 JavaScript 对象的事件属性进行绑定。 例如： 12345678// 通过 HTML 属性直接指定&lt;button onclick=&quot;console.log(&#x27;Button clicked!&#x27;)&quot;&gt;Click me&lt;/button&gt;;// 通过 JavaScript 指定let button = document.getElementById(&#x27;myButton&#x27;);button.onclick = function () &#123; console.log(&#x27;Button clicked!&#x27;);&#125;; 注意，在使用 DOM 0 级事件时，同一个事件只能绑定一个处理函数，多次设置会覆盖之前的处理器。 DOM 2 级事件DOM 2 级事件提供了更多的事件类型和更丰富的事件处理方式。事件绑定主要使用 addEventListener 和 removeEventListener 方法。 addEventListener 方法接受三个参数：事件名称，事件处理函数，和一个布尔值（可以指定事件处理器在捕获阶段或者冒泡阶段执行）。 例如： 123456789let button = document.getElementById(&#x27;myButton&#x27;);// 添加事件处理器button.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;Button clicked!&#x27;);&#125;);// 移除事件处理器button.removeEventListener(&#x27;click&#x27;, handler); 不同于 DOM 0 级事件，DOM 2 级事件可以为同一个事件绑定多个处理函数，这些函数将按照绑定顺序依次执行。同时，可以通过 removeEventListener 移除绑定的事件处理函数。 DOM 3 级事件DOM 3 级事件在 DOM 2 的基础上，引入了更多的事件类型，例如键盘事件、鼠标滚轮事件等。有以下常见的几类： 鼠标事件：click、dblclick、mousedown、mouseup、mousemove、mouseover、mouseout、mouseenter、mouseleave 等。 键盘事件：keydown、keyup、keypress。 表单事件：focus、blur、change、submit。 窗口事件：scroll、resize、load、unload。 3. JavaScript 继承在 JavaScript 中，有多种方法实现对象的继承，其中包括原型链继承、组合继承、原型式继承、寄生式继承、寄生组合式继承，以及 ES6 中引入的基于 class 关键字的继承。 原型链继承JavaScript 的每个对象都有一个指向它的原型（prototype）的链接。当试图访问一个对象的属性时，如果对象内部没有这个属性，那么 JavaScript 就会去对象的原型上找这个属性，这个过程叫做原型链查找。 1234567891011121314151617function Parent() &#123; this.parentValue = &#x27;parent&#x27;;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child() &#123; this.childValue = &#x27;child&#x27;;&#125;// Child 继承自 ParentChild.prototype = new Parent();let child = new Child();console.log(child.getParentValue()); // &#x27;parent&#x27; 缺点：父类的引用属性会被所有实例共享，一个实例修改了父类的引用属性，其他实例的这个属性也会被修改。 组合继承（经典继承）组合继承是 JavaScript 最常用的继承模式。思路是使用原型链实现对原型属性和方法的继承，通过构造函数来实现对实例属性的继承。 12345678910111213141516171819function Parent(value) &#123; this.parentValue = value;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child(value, childValue) &#123; Parent.call(this, value); // 继承实例属性，第一次调用 Parent() this.childValue = childValue;&#125;// 继承方法Child.prototype = new Parent(); // 第二次调用 Parent()Child.prototype.constructor = Child;let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; 原型式继承原型式继承的思路是基于已经存在的对象创建新对象，同时还不必因此创建自定义类型。 123456789101112131415function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;let parent = &#123; parentValue: &#x27;parent&#x27;, getParentValue: function () &#123; return this.parentValue; &#125;,&#125;;let child = object(parent);console.log(child.getParentValue()); // &#x27;parent&#x27; ES5 通过新增 Object.create() 方法规范化了原型式继承。 12345678910111213141516171819202122232425262728293031323334353637var parent = &#123; name: &#x27;parent&#x27;, getName: function () &#123; return this.name; &#125;, sayHello: function () &#123; console.log(&quot;Hello, I&#x27;m &quot; + this.name); &#125;,&#125;;// 创建新对象，并继承于parent对象var child = Object.create(parent);console.log(child.getName()); // 输出 &quot;parent&quot;child.sayHello(); // 输出 &quot;Hello, I&#x27;m parent&quot;// 可以给新对象添加新的属性或者覆盖继承来的属性var child2 = Object.create(parent, &#123; name: &#123; // 覆盖 name 属性 value: &#x27;child2&#x27;, enumerable: true, writable: true, configurable: true, &#125;, age: &#123; // 新增 age 属性 value: 10, enumerable: true, writable: true, configurable: true, &#125;,&#125;);console.log(child2.getName()); // 输出 &quot;child2&quot;child2.sayHello(); // 输出 &quot;Hello, I&#x27;m child2&quot;console.log(child2.age); // 输出 10 寄生式继承寄生式继承的思路是创建一个用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。 1234567891011function createAnother(original) &#123; var clone = object(original); clone.sayHi = function () &#123; console.log(&#x27;hi&#x27;); &#125;; return clone;&#125;let child = createAnother(parent);console.log(child.getParentValue()); // &#x27;parent&#x27;child.sayHi(); // &#x27;hi&#x27; 寄生组合式继承寄生组合式继承是将寄生式继承和组合继承进行组合应用的方法。这种类型的继承效率较高，是 JavaScript 中最理想的继承范式。 123456789101112131415161718192021222324function Parent(value) &#123; this.parentValue = value;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child(value, childValue) &#123; Parent.call(this, value); this.childValue = childValue;&#125;// 寄生组合式继承的核心(function () &#123; // 创建一个没有实例方法的 &quot;类&quot; var Super = function () &#123;&#125;; Super.prototype = Parent.prototype; // 让子类的原型等于 &quot;类&quot; 的实例, 实现继承 Child.prototype = new Super();&#125;)();let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; ES6 的 class 继承ES6 中，可以使用 class 关键字来定义类，并通过 extends 和 super 关键字来实现类的继承。 12345678910111213141516171819class Parent &#123; constructor(value) &#123; this.parentValue = value; &#125; getParentValue() &#123; return this.parentValue; &#125;&#125;class Child extends Parent &#123; constructor(value, childValue) &#123; super(value); // 调用父类的 constructor(value) this.childValue = childValue; &#125;&#125;let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; class 继承的背后其实是原型链继承和构造函数继承的组合，是语法糖。 4. 事件循环JavaScript 是单线程语言，为了实现执行异步操作，所以引入了事件循环(Event Loop)。它是一个持续运行的过程，可以理解为一个实际的循环，它在等待事件发生时继续运行。 宏任务和微任务JavaScript 的任务可以分为宏任务和微任务 宏任务：可以理解为需要在一次事件循环中全部执行完毕的任务，例如setTimeout、setInterval、setImmediate(Node.js 环境)、I/O、UI rendering等。 微任务：可以理解为需要在当前任务执行结束后立即执行的任务，例如Promise、process.nextTick(Node.js 环境)、MutationObserver等。 事件循环过程 执行同步代码，这属于一个宏任务。 执行完所有同步代码后，执行下一个宏任务前，在下一个宏任务开始前，会执行所有的微任务。 当所有微任务执行完毕后，有可能需要进行 UI 渲染。 然后继续下一个宏任务，执行对应的任务队列。 循环上述步骤。 经典题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647console.log(&#x27;1&#x27;);setTimeout(function () &#123; console.log(&#x27;2&#x27;); process.nextTick(function () &#123; console.log(&#x27;3&#x27;); &#125;); new Promise(function (resolve) &#123; console.log(&#x27;4&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;5&#x27;); &#125;);&#125;);new Promise(function (resolve) &#123; console.log(&#x27;7&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;8&#x27;);&#125;);async function async1() &#123; console.log(&#x27;6&#x27;); await async2(); console.log(&#x27;9&#x27;);&#125;async function async2() &#123; console.log(&#x27;10&#x27;);&#125;process.nextTick(function () &#123; console.log(&#x27;11&#x27;);&#125;);async1();new Promise(function (resolve) &#123; console.log(&#x27;12&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;13&#x27;);&#125;);console.log(&#x27;14&#x27;);// 答案1 7 6 10 12 14 8 11 9 13 2 4 5 3 注意，await 后面的东西相当于new Promise(function(resolve) &#123;console.log(&#39;7&#39;);resolve();里面的console.log(&#39;7&#39;) 5. 模块化AMD (Asynchronous Module Definition)AMD 是 “Asynchronous Module Definition” 的缩写，意思就是 “异步模块定义”。它采用异步方式加载模块，模块的加载不影响后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。AMD 的代表实现是 RequireJS。 1234// 定义一个模块define(&#x27;module&#x27;, [&#x27;dep1&#x27;, &#x27;dep2&#x27;], function (dep1, dep2) &#123; return someExportedValue;&#125;); CMD (Common Module Definition)CMD 是 “Common Module Definition” 的缩写，也就是 “通用模块定义”。CMD 采用的是异步加载模块，允许模块和模块之间有依赖关系，也支持就近依赖，只有在用到某个模块的时候再去加载那个模块。CMD 的代表实现是 SeaJS。 1234define(function (require, exports, module) &#123; var dep1 = require(&#x27;dep1&#x27;); exports.action = function () &#123;&#125;;&#125;); CommonJSCommonJS 是 Node.js 模块系统的基础，它用于服务器。每个文件是一个模块，通过 require 来加载模块，通过 exports 或 module.exports 来导出模块。CommonJS 使用同步加载模块的方式。 12var dep1 = require(&#x27;dep1&#x27;);exports.someMethod = function () &#123;&#125;; ES6 ModulesES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。模块不是对象，import 命令会被 JavaScript 引擎静态分析，生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块去取值。 12import &#123; dep1, dep2 &#125; from &#x27;module-name&#x27;;export function someMethod() &#123;&#125; 6. 迭代器和生成器迭代器 (Iterator)迭代器是一种特殊对象，它包含一个叫做 next 的方法。这个方法返回一个结果对象，这个对象有两个属性： value：下一个值 done：布尔类型，如果没有更多的数据则为 true，否则为 false。 迭代器的简单示例： 1234567891011121314151617let iterator = &#123; current: 1, next() &#123; let result = &#123; value: null, done: true &#125;; if (this.current &lt;= 3) &#123; result.value = this.current; result.done = false; this.current++; &#125; return result; &#125;,&#125;;console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().done); // true 生成器（Generator）和 yield 关键字生成器是一种可以返回多个连续值的函数。换句话说，一个生成器就像一个工厂，制造一系列的值。生成器函数通过 * 符号来定义，并且可以通过 yield 关键字来产生一个值。 当一个生成器函数被调用时，它返回一个特殊类型的迭代器，称为生成器对象。这个对象也包含一个 next 方法，但是可以在生成器函数内部控制这个方法的行为。 生成器的简单示例： 12345678910111213141516171819202122// 例子1function* generator() &#123; yield 1; yield 2; yield 3;&#125;let iterator = generator();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().done); // true//例子2function* generator() &#123; const dataIn = yield &#x27;This will be replaced by next() argument&#x27;; console.log(dataIn);&#125;const iter = generator();console.log(iter.next()); // 输出 &#123; value: &#x27;This will be replaced by next() argument&#x27;, done: false &#125;iter.next(&#x27;Hello, generator!&#x27;); // 输出 &#x27;Hello, generator!&#x27; 每次调用生成器对象的 next 方法，就会执行生成器函数直到遇到一个 yield 语句。然后，yield 的值就是 next 方法返回的值。当没有更多的 yield 语句时，done 属性的值就会变成 true。 next() 函数还可以接收一个参数，这个参数可以作为 yield 语句的结果返回给生成器内部。这个特性可以使得生成器和外部环境进行双向的数据交换。比如例子 2 里调用 iter.next(&#39;Hello, generator!&#39;)，传入的参数 &#39;Hello, generator!&#39; 会作为上一次 yield 语句的结果，赋值给 dataIn 变量。然后生成器恢复执行，直到遇到下一个 yield 语句，或者结束。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"八股文","slug":"web前端/八股文","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"八股文","slug":"八股文","permalink":"http://wishao.me/tags/%E5%85%AB%E8%82%A1%E6%96%87/"}]},{"title":"初识vue","slug":"初识vue","date":"2023-07-10T11:00:41.000Z","updated":"2023-07-24T09:49:36.000Z","comments":true,"path":"2023/07/10/初识vue/","link":"","permalink":"http://wishao.me/2023/07/10/%E5%88%9D%E8%AF%86vue/","excerpt":"第一天 学习了 vue 基础语法以及 vue3 的组合式 API","text":"第一天 学习了 vue 基础语法以及 vue3 的组合式 API 一、vue 基础1、引入 vue基础不使用任何脚手架，直接在头部使用&lt;script src=&quot;https://unpkg.com/vue@3&quot;&gt;&lt;/script&gt;引入 vue 在 body 标签里建立一个 id 为 app 的 div，随后在 script 标签里使用Vue.createApp().mount(&#39;#app&#39;)这就是 vue 的最基础的引入 2、最简单的使用在 Vue.createApp()中传入对象，对象里添加 data 方法，return 的就是 vue 基本数据。 1234567891011Vue.createApp(&#123; data() &#123; return &#123; foods: [ &#123; id: 1, name: &#x27;原味鱿鱼丝&#x27;, image: &#x27;./images/原味鱿鱼丝.png&#x27;, purchased: false &#125;, &#123; id: 2, name: &#x27;辣味鱿鱼丝&#x27;, image: &#x27;./images/辣味鱿鱼丝.png&#x27;, purchased: false &#125;, &#123; id: 3, name: &#x27;炭烧味鱿鱼丝&#x27;, image: &#x27;./images/炭烧味鱿鱼丝.png&#x27;, purchased: false &#125;, ], &#125;; &#125;,&#125;).mount(&#x27;#app&#x27;); 随后便可以在那个绑定的 div 中使用基础 vue 语法。 并且这里的对象不只有 data 方法，还有若干别的方法，方便拆分管理 3、v-for v-bind v-modelv-for 指令v-for 用于渲染列表，基本语法如下： 123&lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/li&gt;&lt;/ul&gt; v-for 会遍历 items 数组，并为每个元素生成一个 &lt;li&gt; 元素。每个元素都通过 item 变量可以在模板中访问。key 属性是必需的，用于提高 Vue 追踪每个节点的能力，从而提高渲染性能。 v-bind 指令v-bind 用于绑定元素属性，基本语法如下： 1&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; v-bind 将元素的 disabled 属性绑定到 Vue 实例的 isButtonDisabled 属性。如果 isButtonDisabled 属性的值是 true，则按钮会被禁用。它常用来动态设置 HTML 属性。 简写形式是 :： 1&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 非常常用的是绑定数据，还有绑定 class 类名 v-model 指令v-model 用于实现双向数据绑定，基本语法如下： 1&lt;input v-model=&quot;message&quot; /&gt; v-model 将 input 的 value 属性和 input 的 oninput 事件绑定到 Vue 实例的 message 属性。这样当 input 值发生变化时，message 属性也会随之更新；反之亦然。 v-model 是 Vue 提供的一种特殊语法糖，本质上它是 v-bind 和 v-on 的结合。 4、v-on v-ifv-on 指令能在 html 上绑定方法。所绑定的方法写在 App 对象里的 methods 属性里。比如 1&lt;form v-on:submit=&quot;add&quot;&gt;&lt;/form&gt; 可以缩写成@。然后再加上 form 表单触发 submit 事件的时候默认会刷新页面，但是我们不需要它提交表单，所以用 vue 提供的方法之间阻止，写成： 1&lt;form @submit.prevent=&quot;add&quot;&gt;&lt;/form&gt; v-if 指令就是把 js 能做的判断能写到 html 标签里，如果满足才显示这个标签。比如 1&lt;div v-if=&quot;items.length &gt; 3&quot;&gt;&lt;/div&gt; 满足 items 的长度的时候才显示这个 div 标签 还有 v-else-if 与 v-else 可以用，不过多赘述 5、拆分组件这是 vue 最核心的思想。比如首先可以把基础导入写成Vue.createApp(App).mount(&#39;#app&#39;)，然后就可以新建一个文件 App.js，把东西都写在这里。然后使用 es6 的导出导入语法挂载 在 App 对象里，添加 template 属性，属性是反引号字符串，然后就可以把所有之前写在 id 为 app 的 div 里的 html 写在反引号里了。vue 会为我们挂载并使用 6、细化拆分再在这个 app.js 写多了东西感觉复杂，还能细化拆分。把 App 对象里的所有东西都删除，只留一个 template 属性，再加一个 components 方法，用 es6 的导入对象，这就是要引入的东西。再新建个文件，写和 app.js 类似的对象导出。把传入的对象写成 html 标签写入 App 的 template 里，实现了组件进一步细化拆分 7、父子组件通信父传子在父组件的 template 里，写子组件的 html 标签时，添加一个属性。比如 1&lt;son :message=&quot;mes1&quot;&gt;&lt;/son&gt; 然后在子组件里添加一个 props 属性，是个对象，对象里是信息的名加上信息类型，就能传入信息了。比如 12345&#123; props: &#123; mes1: String, &#125;&#125; 子传父使用$emit方法，子组件可以向父组件发送事件。这个方法接收两个参数，第一个参数是事件的名称，第二个参数是随事件一起发送的数据。当子组件调用 $emit 方法时，会触发一个事件，这个事件会向上冒泡到父组件，父组件可以通过 v-on 或者 @ 对这个事件进行监听，并在回调函数中接收数据，完成子组件到父组件的通信。举例： 子组件： 12345678910&#123; template: ` &lt;button @click=&quot;notifyParent&quot;&gt;Click me&lt;/button&gt; ` methods: &#123; notifyParent() &#123; this.$emit(&#x27;childClicked&#x27;, &#x27;Hello, parent!&#x27;); &#125; &#125;&#125; 父组件： 1234567891011121314import ChildComponent from &#x27;./ChildComponent.vue&#x27;;export default &#123; components: &#123; ChildComponent, &#125;, template: ` &lt;child-component @childClicked=&quot;handleChildClick&quot;&gt;&lt;/child-component&gt; `, methods: &#123; handleChildClick(message) &#123; console.log(message); // 输出 &#x27;Hello, parent!&#x27; &#125;, &#125;,&#125;; 能够点击子组件按钮，控制台输出 Hello, parent! 感觉这个语法比较费解，大致过程是： 首先，在最终要点击的子组件上绑定函数 然后在这个函数上，使用$emit 方法，第一个参数是传递的名称，第二个参数是传递的信息。这样做等于是向调用它的人暴露出了第一个参数命名的属性 再然后，在父组件里，导入子组件，在 template 中使用此组件，并用 v-on，父组件的方法监听暴露出来的属性。 这时候，父组件监听函数的定义里参数便是子组件传递的信息（即第二个参数），便能在父组件做一些事情。每当子组件的函数被调用，父组件的监听函数也就跟着被调用，完成了子传父。 二、vue3 组合式 API 基础1、安装运行使用 creat-vue 脚手架构建(基于 Vite) 1npm init vue@latest 2、基本文件结构根目录 index.html 是最终入口，最后 vue 会把东西挂载至此 其他都是一些工程的配置文件 src在这里进行主要代码的书写 App.vue 根组件文件 main.js 项目的入口文件 components 文件夹 存放项目使用的公共组件 assets 文件夹 存放每个页面对应的 css、js 公共函数以及图片文件 public公共资源目录 dist存放打包好生成的文件 3、基本使用从 App.vue 开始vue3 使用了组合式语法，简化了 vue2 的语法。在 &lt;script&gt; 标签内编写 JavaScript，&lt;template&gt; 标签内编写 HTML。使用双大括号 &#123;&#123; &#125;&#125; 包含变量或语句。 响应式数据使用 reactive() 和 ref() 使 HTML 中的变量可变，即 JavaScript 更改变量后，HTML 会重新渲染新值。 ref()：创建一个响应式数据对象。ref() 返回的对象包含一个 .value 属性用于获取或设置内部值。 reactive()：接受一个普通对象并返回其代理，等同于 Vue 2.x 的Vue.observable()。 计算属性用于影响响应式数据。定义一个函数来更改响应式数据，得到的结果仍然是响应式的，可以在 HTML 中实时渲染。 使用 computed() 函数创建计算属性，这个函数接收一个 getter 函数并返回一个不可变的响应式 ref 对象。当依赖的响应式数据发生变化时，getter 函数会自动重新计算。 最好不要传入有副作用的函数。计算属性是只读的 监听使用 watch() 函数监听数据变化，数据发生变化时会触发回调函数。 1watch(xxx, (newVal, oldVal) =&gt; &#123;&#125;); immediate 参数：放在最后，如果指定了这个参数，将首先立即执行一次回调函数。 默认为浅层监听，即如果监听的是一个对象，对象的属性发生变化不会调用回调函数。如果要进行深度监听，需要指定 deep 参数。 如果需要精确监听某个属性，可以将回调函数改写为两个，第一个返回需要监听的属性。 生命周期函数 onBeforeMount(): 在挂载开始之前调用。 onMounted(): 在组件挂载到 DOM 后调用，可以访问和操作 DOM 元素。 onBeforeUpdate(): 在数据更新，导致的虚拟 DOM 重新渲染和打补丁之前调用。 onUpdated(): 在组件 DOM 已经更新，即数据的更改已经体现在 DOM 中之后调用。 onBeforeUnmount(): 新的生命周期函数，在组件卸载之前被调用，可以进行一些清理工作。 onUnmounted(): 在组件卸载并从 DOM 中移除后被调用。 注意： beforeCreate 和 created 在 Vue 3 的组合式 API 中没有直接的等价物。 组件父子通信 父传子：在调用子组件时，添加一个属性，即要传递的信息。子组件使用 defineProps() 来接收。如果是响应式数据，需要在添加属性时前面加一个冒号 :。 子传父：在父组件中定义变量，然后在使用子组件时添加一个属性来传递，子组件使用后可以传递信息。注意，使用子组件时需要在方法前加 @，然后子组件通过 defineEmits() 函数来生成传递方法。 模板引用为了获取 DOM 组件。 首先调用 ref() 函数，传入 null，然后在模板 HTML 中，用 ref 属性绑定该变量。这样我们就可以通过这个变量获取到 DOM。注意，需要在组件挂载完成后才能获取，所以要在 onMounted 生命周期或者之后。 跨层传递数据层组件使用 provide() 函数提供数据，provide(&#39;别名&#39;, 数据)。 底层组件使用 inject() 函数获取数据，inject(&#39;别名&#39;)。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.me/tags/vue/"},{"name":"自学","slug":"自学","permalink":"http://wishao.me/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"紧急事件","slug":"紧急事件","date":"2023-07-09T18:08:30.000Z","updated":"2023-07-10T14:25:29.639Z","comments":true,"path":"2023/07/10/紧急事件/","link":"","permalink":"http://wishao.me/2023/07/10/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"晚上才看见暑假里要每日写总结传博客，遂急忙搭建此站。目前一切都是临时的，后面再做理会。大改的东西有很多，顶部栏完全没弄，访问统计也没弄，友链，关于我之类的都还没，纯毛坯房，后面再加","categories":[{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.me/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[{"name":"紧急事件","slug":"紧急事件","permalink":"http://wishao.me/tags/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/"}],"author":"WiSHao"},{"title":"Hello World","slug":"hello-world","date":"2023-07-09T13:00:00.000Z","updated":"2023-07-15T13:37:00.000Z","comments":true,"path":"2023/07/09/hello-world/","link":"","permalink":"http://wishao.me/2023/07/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.me/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[],"author":"volantis"}],"categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"小程序","slug":"web前端/小程序","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"瞎折腾","slug":"瞎折腾","permalink":"http://wishao.me/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"Windows调教","slug":"瞎折腾/Windows调教","permalink":"http://wishao.me/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/Windows%E8%B0%83%E6%95%99/"},{"name":"html5游戏","slug":"web前端/html5游戏","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/html5%E6%B8%B8%E6%88%8F/"},{"name":"TypeScript学习","slug":"web前端/TypeScript学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/TypeScript%E5%AD%A6%E4%B9%A0/"},{"name":"react学习","slug":"web前端/react学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/react%E5%AD%A6%E4%B9%A0/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"},{"name":"八股文","slug":"web前端/八股文","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.me/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.me/tags/vue/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.me/tags/TypeScript/"},{"name":"小程序","slug":"小程序","permalink":"http://wishao.me/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"支付宝小程序","slug":"支付宝小程序","permalink":"http://wishao.me/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Windows10","slug":"Windows10","permalink":"http://wishao.me/tags/Windows10/"},{"name":"Windows11，Defender","slug":"Windows11，Defender","permalink":"http://wishao.me/tags/Windows11%EF%BC%8CDefender/"},{"name":"关闭","slug":"关闭","permalink":"http://wishao.me/tags/%E5%85%B3%E9%97%AD/"},{"name":"小软件","slug":"小软件","permalink":"http://wishao.me/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"自学","slug":"自学","permalink":"http://wishao.me/tags/%E8%87%AA%E5%AD%A6/"},{"name":"canvas","slug":"canvas","permalink":"http://wishao.me/tags/canvas/"},{"name":"游戏","slug":"游戏","permalink":"http://wishao.me/tags/%E6%B8%B8%E6%88%8F/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记，手写还原","slug":"笔记，手写还原","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0%EF%BC%8C%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"},{"name":"react","slug":"react","permalink":"http://wishao.me/tags/react/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.me/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"},{"name":"拾遗","slug":"拾遗","permalink":"http://wishao.me/tags/%E6%8B%BE%E9%81%97/"},{"name":"八股文","slug":"八股文","permalink":"http://wishao.me/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"紧急事件","slug":"紧急事件","permalink":"http://wishao.me/tags/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/"}]}