{"meta":{"title":"WiSHao'blog","subtitle":"WiSHao的博客","description":"终于开始记点东西","author":"WiSHao","url":"http://wishao.me","root":"/"},"pages":[{"title":"","date":"2023-07-11T01:55:09.268Z","updated":"2023-07-11T01:55:09.268Z","comments":true,"path":"404.html","permalink":"http://wishao.me/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-07-11T02:15:52.215Z","updated":"2023-07-11T02:15:52.215Z","comments":true,"path":"about/index.html","permalink":"http://wishao.me/about/index.html","excerpt":"","text":"我 小前端一个，被基友坑入门，一入门深似海，但是意外还挺喜欢，就一直在学 音游人，这是我的osu主页，主玩戳泡泡，球球osu大申带带 其他没什么可说的。虽然说现在的互联网上根本没有隐私可言，但是我也没有义务在这做我的简历。为我留下最后的一份神秘，好吗？若想知道更多，可以去翻我的社交账号。 碎碎念虽说自高中毕业的暑假就想搭建自己的博客了，但是初期实在是技术不足，连教程看着都费劲，就不了了之。后来学习了一些知识，却深陷我的强迫症，找不到我满意的主题。就像历史上许多重大事件都是由意外推动的一样，某天有不可抗力突然给了我一晚上的限制让我必须搭建好我的博客，我居然在几小时内完成了主题的挑选，不可思议。 差不多就这样了，或许我写的东西会很水，无所谓了，反正没人看，有个地方放点东西也挺好，也没想给谁看。如果你无意间翻看到了我的博客，恭喜你，有缘人，或许可以加一下我的社交账号？"},{"title":"我的朋友们","date":"2023-07-10T13:32:53.949Z","updated":"2023-07-10T13:32:53.949Z","comments":true,"path":"friends/index.html","permalink":"http://wishao.me/friends/index.html","excerpt":"","text":"欢迎捧场"},{"title":"所有分类","date":"2023-07-10T14:22:24.659Z","updated":"2023-07-10T14:22:24.659Z","comments":true,"path":"categories/index.html","permalink":"http://wishao.me/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-07-10T13:42:32.150Z","updated":"2023-07-10T13:42:32.150Z","comments":true,"path":"tags/index.html","permalink":"http://wishao.me/tags/index.html","excerpt":"","text":"点击查看含此标签的文章"}],"posts":[{"title":"前端零碎拾遗","slug":"前端零碎拾遗","date":"2023-07-12T13:45:00.000Z","updated":"2023-07-12T14:18:33.836Z","comments":true,"path":"2023/07/12/前端零碎拾遗/","link":"","permalink":"http://wishao.me/2023/07/12/%E5%89%8D%E7%AB%AF%E9%9B%B6%E7%A2%8E%E6%8B%BE%E9%81%97/","excerpt":"汇总下写着写着突然又想起来或者才听说的东西","text":"汇总下写着写着突然又想起来或者才听说的东西 html经常忘的标签 &lt;hr/&gt;横线 emmet语法 TAB键+标签名快速生成标签 div*4生成4个div ul&gt;li快速生成包含关系 div+p快速生成兄弟关系 span.nar快速标签内类名 .aad$*5快速依次生成5个aad类名(无$就生一样的) div{东西} css去下划线text-decoration: none; 去输入框点击时边框outline:none; 定位时用负边距居中比如说定位是left: 50%，元素100px宽那可以设置margin-left: -50px实现居中 :root这个伪类表示html标签，而且比他等级更高，是dom树里根中之根，可以存点变量啥的 var()函数可以调用存在父节点里的变量 主义变量命名要以两个横杠–开头 JavaScriptJS读元素css属性使用xxx.style的方法只能读到内联的css，外联读出来全是空的 可以用getComputedStyle(elem, [pseudo]) 返回一个对象，包含所有style。比如： 1234let computedStyle = getComputedStyle(document.body);console.log( computedStyle.marginTop ); // 5px console.log( computedStyle.color ); // rgb(255, 0, 0) .reduce() 方法arr.reduce(function(accumulator, item, index, array) &#123; // ...&#125;, [initial]); accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。(相当于一个累加器) item —— 当前的数组元素。 index —— 当前索引。 arr —— 数组本身。 .replace方法str.replace(regexp, replacement) 使用 replacement 替换在字符串 str 中找到的 regexp 的匹配项（如果带有修饰符 g 则替换所有匹配项，否则只替换第一个） .split方法str.split(分隔符) 用以创建一个以分隔符为分割标志的数组 .join方法arr.join(插入符) 返回一个字符串，这个字符串是由数组所有元素拼成，中间夹着插入符 如果不写就默认用,间隔，让它没有的话得写空字符串&#39;&#39; Array.prototype.slice.call()可将类数组(arguments,NodeList)，字符串(String)转换成数组。 为什么用它呢，因为比如NodeList缺像是map之类的数组方法，转化就能用了 Object.prototype.toString.call(fn) !&#x3D;&#x3D; ‘[object Function]’判断fn是不是函数 动态的居中问题比如说有个框，宽度定死了但是高度没定，你预先不知道有多少内容会给高度撑成多少，怎么上下的居中 可以先用定位，给他设置top:50%，然后js给他负的边框，数值是自己的高度一半（当然是用js获取可视高度） xxxx.style.marginTop = &#39;-$&#123;xxxx.offsetHeight / 2&#125;px&#39; 展开运算符的覆写展开操作符...会将一个对象的所有可枚举属性复制到新的对象上。如果在展开操作符之后我们再定义一个与展开对象中同名的属性，那么这个新定义的属性的值将覆盖展开操作符复制过来的同名属性。 比如说 12345const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; ...obj1, b: 3, c: 4 &#125;;console.log(obj2); // 输出 &#123; a: 1, b: 3, c: 4 &#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"拾遗","slug":"拾遗","permalink":"http://wishao.me/tags/%E6%8B%BE%E9%81%97/"}]},{"title":"Redux状态管理","slug":"Redux状态管理","date":"2023-07-12T13:36:33.000Z","updated":"2023-07-12T13:43:37.889Z","comments":true,"path":"2023/07/12/Redux状态管理/","link":"","permalink":"http://wishao.me/2023/07/12/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","excerpt":"为了深入理解Redux状态管理工具，手写一个简化的（也是作业）","text":"为了深入理解Redux状态管理工具，手写一个简化的（也是作业） 手写一个类似Redux的createStore，实现一个简单的列表增删。 输入名称，序号自增并以此名称添加进列表；输入要删除的序号，就删除对应序号的行 index.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;redux&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;add&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入名称&quot; /&gt; &lt;button&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;delete&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入要删除的id&quot; /&gt; &lt;button&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;show&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const addTextDOM = document.querySelector(&#x27;.add input&#x27;);const addBtnDOM = document.querySelector(&#x27;.add button&#x27;);const deleteTextDOM = document.querySelector(&#x27;.delete input&#x27;);const deleteBtnDOM = document.querySelector(&#x27;.delete button&#x27;);const showDOM = document.querySelector(&#x27;.show&#x27;);// 手写简单Reduxfunction createStore(reducer) &#123; // 闭包内数据，一个是所存数据，一个是注册的函数 // 初始化 state let state = reducer(undefined, &#123;&#125;); const listeners = []; // 从闭包里获取state的函数 const getState = () =&gt; state; // 核心，dispatch函数，使用传入的reducer更新state，同时触发所有注册的函数 const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach((listener) =&gt; listener()); &#125;; // 注册函数，返回一个取消注册的函数 const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; const index = listeners.indexOf(listener); listeners.splice(index, 1); &#125;; &#125;; return &#123; getState, dispatch, subscribe &#125;;&#125;// 此例子的reducer，这里state进行了初始化，这样规定了state的数据结构// names数组里面放的是有id和name俩属性的对象function reducer(state = &#123; id: 0, names: [] &#125;, action) &#123; switch (action.type) &#123; case &#x27;ADD&#x27;: return &#123; id: state.id + 1, names: [...state.names, &#123; id: state.id, name: action.name &#125;], &#125;; case &#x27;DELETE&#x27;: return &#123; // 这里重写了展开属性，覆盖了原来的names ...state, names: state.names.filter((item) =&gt; item.id !== action.id), &#125;; default: return state; &#125;&#125;// 利用手写的createStore函数创建storeconst store = createStore(reducer);// 渲染函数function render() &#123; const currentState = store.getState(); // 获取当前的状态 showDOM.innerHTML = currentState.names.map((item) =&gt; `&lt;p&gt;序号:$&#123;item.id&#125;，名称:$&#123;item.name&#125;&lt;/p&gt;`).join(&#x27;&#x27;);&#125;// 注册渲染的函数，同时返回一个取消注册的函数（虽然说没用到吧const unRender = store.subscribe(render);addBtnDOM.addEventListener(&#x27;click&#x27;, () =&gt; &#123; const name = addTextDOM.value; store.dispatch(&#123; type: &#x27;ADD&#x27;, name &#125;); addTextDOM.value = &#x27;&#x27;;&#125;);deleteBtnDOM.addEventListener(&#x27;click&#x27;, () =&gt; &#123; const id = Number(deleteTextDOM.value); store.dispatch(&#123; type: &#x27;DELETE&#x27;, id &#125;); deleteTextDOM.value = &#x27;&#x27;;&#125;);","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.me/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"}]},{"title":"day3 Vue Pinia","slug":"day3-Vue-Pinia","date":"2023-07-12T03:26:14.000Z","updated":"2023-07-12T13:43:38.957Z","comments":true,"path":"2023/07/12/day3-Vue-Pinia/","link":"","permalink":"http://wishao.me/2023/07/12/day3-Vue-Pinia/","excerpt":"Vue 状态管理库 Pinia，非常好用","text":"Vue 状态管理库 Pinia，非常好用 PiniaPinia 是一款轻量级的 Vue 状态管理库，可以使用它跨组件或页面共享状态。 相当于组件的组件，可以用来定义一些共用的东西，也可以用来传递数据。 能用vue3的组合式语法来写，与本来的组件完全一致，非常直观好用 1. 引入先安装 1npm i pinia 然后在main.js引入 1234import &#123; createPinia &#125; from &#x27;pinia&#x27;const app = createApp(App)app.use(pinia) 2. 基础使用一般来说，先在src文件夹里创建一个stores文件夹，专门存放pinia组件 比如定义一个计数器的组件，使用了组合式语法，定义一个响应式数据和一个方法 123456789101112131415import &#123; defineStore &#125; from &#x27;pinia&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123; const count = ref(0); const increment = () =&gt; &#123; count.value++; &#125;; return &#123; count, increment, &#125;;&#125;); 步骤是先引入defineStore，使用它定义一个组件供导出使用 然后在vue文件里导入useCounterStore，使用变量接收，就能像这样使用了 1234567891011&lt;script setup&gt; import &#123; useCounterStore &#125; from &#x27;./stores/counter&#x27;; const counterStore = useCounterStore(); console.log(counterStore);&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;counterStore.increment&quot;&gt;&#123;&#123; counterStore.count &#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 3. getters实现使用computed计算属性实现，然后导出，比如 1const doubleCount = computed(() =&gt; count.value * 2); 4. 异步请求比如网络请求axios，直接在store里面写，写完导出，就能直接在引入的地方用了 5. 解构赋值看之前的代码，引入使用的时候每次都要写counterStore.xxx，很啰嗦。 可以使用解构赋值来赋值给变量 123const &#123;count, doubleCount&#125; = storeToRefs(counterStore)// 注意，这个方法只能获取到响应式数据，没法获得方法// 获取方法，比如increment，直接不用这个函数，直接解构赋值就行了（因为是引用值） 注意要用它的storeToRefs方法，不然直接写的话会丢失响应式数据的特性。获取到的是响应式对象","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.me/tags/vue/"},{"name":"自学","slug":"自学","permalink":"http://wishao.me/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"day2 js基础复习","slug":"day2js基础复习","date":"2023-07-11T12:30:37.000Z","updated":"2023-07-12T13:47:18.698Z","comments":true,"path":"2023/07/11/day2js基础复习/","link":"","permalink":"http://wishao.me/2023/07/11/day2js%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","excerpt":"复习原生 js 知识","text":"复习原生 js 知识 1. this 指向问题里的 call apply bindcallcall是一个方法，它的作用是改变函数的this指向。第一个参数是用于替换this的值，后续的参数是传递给函数的参数。例如： 1234567function showName(age, job) &#123; console.log(`My name is $&#123;this.name&#125;, I&#x27;m $&#123;age&#125; years old and I am a $&#123;job&#125;.`);&#125;let person = &#123; name: &#x27;Tom&#x27; &#125;;showName.call(person, 25, &#x27;engineer&#x27;); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. call会立即执行函数。 applyapply方法的作用和call类似，都是用于改变函数的this指向，不过apply接收的参数是一个数组（或类数组对象），第一个参数同样是用于替换this的值，第二个参数是传递给函数的参数数组。例如： 1234let person = &#123; name: &#x27;Tom&#x27; &#125;;let args = [25, &#x27;engineer&#x27;];showName.apply(person, args); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. 和call一样，apply也会立即执行函数。 bindbind方法也是用于改变函数的this指向，它的使用方法和call类似，第一个参数是用于替换this的值，后续的参数是传递给函数的参数。不过，不同于call和apply，bind不会立即执行函数，而是返回一个新的函数。例如： 12345let person = &#123; name: &#x27;Tom&#x27; &#125;;let newShowName = showName.bind(person, 25, &#x27;engineer&#x27;);newShowName(); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. 总结： call和apply的主要作用都是改变函数的this指向，并立即执行函数。它们的区别主要在于参数的传递方式，call是将参数依次传入，而apply则是以数组形式传入参数。 bind方法也可以改变函数的this指向，但不同的是，它会返回一个新的函数，可以在需要的时候再去调用这个新函数。 2. 事件等级DOM 0 级事件DOM 0 级事件又称为原始事件模型，其事件绑定方法非常简单，直接在 HTML 元素上通过事件属性（如 onclick、onload、onmouseover 等）绑定 JavaScript 函数，或者在 JavaScript 代码中通过 JavaScript 对象的事件属性进行绑定。 例如： 12345678// 通过 HTML 属性直接指定&lt;button onclick=&quot;console.log(&#x27;Button clicked!&#x27;)&quot;&gt;Click me&lt;/button&gt;;// 通过 JavaScript 指定let button = document.getElementById(&#x27;myButton&#x27;);button.onclick = function () &#123; console.log(&#x27;Button clicked!&#x27;);&#125;; 注意，在使用 DOM 0 级事件时，同一个事件只能绑定一个处理函数，多次设置会覆盖之前的处理器。 DOM 2 级事件DOM 2 级事件提供了更多的事件类型和更丰富的事件处理方式。事件绑定主要使用 addEventListener 和 removeEventListener 方法。 addEventListener 方法接受三个参数：事件名称，事件处理函数，和一个布尔值（可以指定事件处理器在捕获阶段或者冒泡阶段执行）。 例如： 123456789let button = document.getElementById(&#x27;myButton&#x27;);// 添加事件处理器button.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;Button clicked!&#x27;);&#125;);// 移除事件处理器button.removeEventListener(&#x27;click&#x27;, handler); 不同于 DOM 0 级事件，DOM 2 级事件可以为同一个事件绑定多个处理函数，这些函数将按照绑定顺序依次执行。同时，可以通过 removeEventListener 移除绑定的事件处理函数。 DOM 3 级事件DOM 3 级事件在 DOM 2 的基础上，引入了更多的事件类型，例如键盘事件、鼠标滚轮事件等。有以下常见的几类： 鼠标事件：click、dblclick、mousedown、mouseup、mousemove、mouseover、mouseout、mouseenter、mouseleave 等。 键盘事件：keydown、keyup、keypress。 表单事件：focus、blur、change、submit。 窗口事件：scroll、resize、load、unload。 3. JavaScript 继承在 JavaScript 中，有多种方法实现对象的继承，其中包括原型链继承、组合继承、原型式继承、寄生式继承、寄生组合式继承，以及 ES6 中引入的基于 class 关键字的继承。 原型链继承JavaScript 的每个对象都有一个指向它的原型（prototype）的链接。当试图访问一个对象的属性时，如果对象内部没有这个属性，那么 JavaScript 就会去对象的原型上找这个属性，这个过程叫做原型链查找。 1234567891011121314151617function Parent() &#123; this.parentValue = &#x27;parent&#x27;;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child() &#123; this.childValue = &#x27;child&#x27;;&#125;// Child 继承自 ParentChild.prototype = new Parent();let child = new Child();console.log(child.getParentValue()); // &#x27;parent&#x27; 缺点：父类的引用属性会被所有实例共享，一个实例修改了父类的引用属性，其他实例的这个属性也会被修改。 组合继承（经典继承）组合继承是 JavaScript 最常用的继承模式。思路是使用原型链实现对原型属性和方法的继承，通过构造函数来实现对实例属性的继承。 12345678910111213141516171819function Parent(value) &#123; this.parentValue = value;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child(value, childValue) &#123; Parent.call(this, value); // 继承实例属性，第一次调用 Parent() this.childValue = childValue;&#125;// 继承方法Child.prototype = new Parent(); // 第二次调用 Parent()Child.prototype.constructor = Child;let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; 原型式继承原型式继承的思路是基于已经存在的对象创建新对象，同时还不必因此创建自定义类型。 123456789101112131415function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;let parent = &#123; parentValue: &#x27;parent&#x27;, getParentValue: function () &#123; return this.parentValue; &#125;,&#125;;let child = object(parent);console.log(child.getParentValue()); // &#x27;parent&#x27; ES5 通过新增 Object.create() 方法规范化了原型式继承。 12345678910111213141516171819202122232425262728293031323334353637var parent = &#123; name: &#x27;parent&#x27;, getName: function () &#123; return this.name; &#125;, sayHello: function () &#123; console.log(&quot;Hello, I&#x27;m &quot; + this.name); &#125;,&#125;;// 创建新对象，并继承于parent对象var child = Object.create(parent);console.log(child.getName()); // 输出 &quot;parent&quot;child.sayHello(); // 输出 &quot;Hello, I&#x27;m parent&quot;// 可以给新对象添加新的属性或者覆盖继承来的属性var child2 = Object.create(parent, &#123; name: &#123; // 覆盖 name 属性 value: &#x27;child2&#x27;, enumerable: true, writable: true, configurable: true, &#125;, age: &#123; // 新增 age 属性 value: 10, enumerable: true, writable: true, configurable: true, &#125;,&#125;);console.log(child2.getName()); // 输出 &quot;child2&quot;child2.sayHello(); // 输出 &quot;Hello, I&#x27;m child2&quot;console.log(child2.age); // 输出 10 寄生式继承寄生式继承的思路是创建一个用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。 1234567891011function createAnother(original) &#123; var clone = object(original); clone.sayHi = function () &#123; console.log(&#x27;hi&#x27;); &#125;; return clone;&#125;let child = createAnother(parent);console.log(child.getParentValue()); // &#x27;parent&#x27;child.sayHi(); // &#x27;hi&#x27; 寄生组合式继承寄生组合式继承是将寄生式继承和组合继承进行组合应用的方法。这种类型的继承效率较高，是 JavaScript 中最理想的继承范式。 123456789101112131415161718192021222324function Parent(value) &#123; this.parentValue = value;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child(value, childValue) &#123; Parent.call(this, value); this.childValue = childValue;&#125;// 寄生组合式继承的核心(function () &#123; // 创建一个没有实例方法的 &quot;类&quot; var Super = function () &#123;&#125;; Super.prototype = Parent.prototype; // 让子类的原型等于 &quot;类&quot; 的实例, 实现继承 Child.prototype = new Super();&#125;)();let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; ES6 的 class 继承ES6 中，可以使用 class 关键字来定义类，并通过 extends 和 super 关键字来实现类的继承。 12345678910111213141516171819class Parent &#123; constructor(value) &#123; this.parentValue = value; &#125; getParentValue() &#123; return this.parentValue; &#125;&#125;class Child extends Parent &#123; constructor(value, childValue) &#123; super(value); // 调用父类的 constructor(value) this.childValue = childValue; &#125;&#125;let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; class 继承的背后其实是原型链继承和构造函数继承的组合，是语法糖。 4. 事件循环JavaScript 是单线程语言，为了实现执行异步操作，所以引入了事件循环(Event Loop)。它是一个持续运行的过程，可以理解为一个实际的循环，它在等待事件发生时继续运行。 宏任务和微任务JavaScript 的任务可以分为宏任务和微任务 宏任务：可以理解为需要在一次事件循环中全部执行完毕的任务，例如setTimeout、setInterval、setImmediate(Node.js 环境)、I/O、UI rendering等。 微任务：可以理解为需要在当前任务执行结束后立即执行的任务，例如Promise、process.nextTick(Node.js 环境)、MutationObserver等。 事件循环过程 执行同步代码，这属于一个宏任务。 执行完所有同步代码后，执行下一个宏任务前，在下一个宏任务开始前，会执行所有的微任务。 当所有微任务执行完毕后，有可能需要进行 UI 渲染。 然后继续下一个宏任务，执行对应的任务队列。 循环上述步骤。 经典题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647console.log(&#x27;1&#x27;);setTimeout(function () &#123; console.log(&#x27;2&#x27;); process.nextTick(function () &#123; console.log(&#x27;3&#x27;); &#125;); new Promise(function (resolve) &#123; console.log(&#x27;4&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;5&#x27;); &#125;);&#125;);new Promise(function (resolve) &#123; console.log(&#x27;7&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;8&#x27;);&#125;);async function async1() &#123; console.log(&#x27;6&#x27;); await async2(); console.log(&#x27;9&#x27;);&#125;async function async2() &#123; console.log(&#x27;10&#x27;);&#125;process.nextTick(function () &#123; console.log(&#x27;11&#x27;);&#125;);async1();new Promise(function (resolve) &#123; console.log(&#x27;12&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;13&#x27;);&#125;);console.log(&#x27;14&#x27;);// 答案1 7 6 10 12 14 8 11 9 13 2 4 5 3 注意，await 后面的东西相当于new Promise(function(resolve) &#123;console.log(&#39;7&#39;);resolve();里面的console.log(&#39;7&#39;) 5. 模块化AMD (Asynchronous Module Definition)AMD 是 “Asynchronous Module Definition” 的缩写，意思就是 “异步模块定义”。它采用异步方式加载模块，模块的加载不影响后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。AMD 的代表实现是 RequireJS。 1234// 定义一个模块define(&#x27;module&#x27;, [&#x27;dep1&#x27;, &#x27;dep2&#x27;], function (dep1, dep2) &#123; return someExportedValue;&#125;); CMD (Common Module Definition)CMD 是 “Common Module Definition” 的缩写，也就是 “通用模块定义”。CMD 采用的是异步加载模块，允许模块和模块之间有依赖关系，也支持就近依赖，只有在用到某个模块的时候再去加载那个模块。CMD 的代表实现是 SeaJS。 1234define(function (require, exports, module) &#123; var dep1 = require(&#x27;dep1&#x27;); exports.action = function () &#123;&#125;;&#125;); CommonJSCommonJS 是 Node.js 模块系统的基础，它用于服务器。每个文件是一个模块，通过 require 来加载模块，通过 exports 或 module.exports 来导出模块。CommonJS 使用同步加载模块的方式。 12var dep1 = require(&#x27;dep1&#x27;);exports.someMethod = function () &#123;&#125;; ES6 ModulesES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。模块不是对象，import 命令会被 JavaScript 引擎静态分析，生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块去取值。 12import &#123; dep1, dep2 &#125; from &#x27;module-name&#x27;;export function someMethod() &#123;&#125; 6. 迭代器和生成器迭代器 (Iterator)迭代器是一种特殊对象，它包含一个叫做 next 的方法。这个方法返回一个结果对象，这个对象有两个属性： value：下一个值 done：布尔类型，如果没有更多的数据则为 true，否则为 false。 迭代器的简单示例： 1234567891011121314151617let iterator = &#123; current: 1, next() &#123; let result = &#123; value: null, done: true &#125;; if (this.current &lt;= 3) &#123; result.value = this.current; result.done = false; this.current++; &#125; return result; &#125;,&#125;;console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().done); // true 生成器（Generator）和 yield 关键字生成器是一种可以返回多个连续值的函数。换句话说，一个生成器就像一个工厂，制造一系列的值。生成器函数通过 * 符号来定义，并且可以通过 yield 关键字来产生一个值。 当一个生成器函数被调用时，它返回一个特殊类型的迭代器，称为生成器对象。这个对象也包含一个 next 方法，但是可以在生成器函数内部控制这个方法的行为。 生成器的简单示例： 12345678910111213141516171819202122// 例子1function* generator() &#123; yield 1; yield 2; yield 3;&#125;let iterator = generator();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().done); // true//例子2function* generator() &#123; const dataIn = yield &#x27;This will be replaced by next() argument&#x27;; console.log(dataIn);&#125;const iter = generator();console.log(iter.next()); // 输出 &#123; value: &#x27;This will be replaced by next() argument&#x27;, done: false &#125;iter.next(&#x27;Hello, generator!&#x27;); // 输出 &#x27;Hello, generator!&#x27; 每次调用生成器对象的 next 方法，就会执行生成器函数直到遇到一个 yield 语句。然后，yield 的值就是 next 方法返回的值。当没有更多的 yield 语句时，done 属性的值就会变成 true。 next() 函数还可以接收一个参数，这个参数可以作为 yield 语句的结果返回给生成器内部。这个特性可以使得生成器和外部环境进行双向的数据交换。比如例子 2 里调用 iter.next(&#39;Hello, generator!&#39;)，传入的参数 &#39;Hello, generator!&#39; 会作为上一次 yield 语句的结果，赋值给 dataIn 变量。然后生成器恢复执行，直到遇到下一个 yield 语句，或者结束。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"八股文","slug":"web前端/八股文","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"八股文","slug":"八股文","permalink":"http://wishao.me/tags/%E5%85%AB%E8%82%A1%E6%96%87/"}]},{"title":"day1初识vue","slug":"day1初识vue","date":"2023-07-10T11:00:41.000Z","updated":"2023-07-10T14:28:33.183Z","comments":true,"path":"2023/07/10/day1初识vue/","link":"","permalink":"http://wishao.me/2023/07/10/day1%E5%88%9D%E8%AF%86vue/","excerpt":"第一天 学习了vue基础语法以及vue3的组合式API","text":"第一天 学习了vue基础语法以及vue3的组合式API 一、vue基础1、引入vue基础不使用任何脚手架，直接在头部使用&lt;script src=&quot;https://unpkg.com/vue@3&quot;&gt;&lt;/script&gt;引入vue 在body标签里建立一个id为app的div，随后在script标签里使用Vue.createApp().mount(&#39;#app&#39;)这就是vue的最基础的引入 2、最简单的使用在Vue.createApp()中传入对象，对象里添加data方法，return的就是vue基本数据。 1234567891011Vue.createApp(&#123; data() &#123; return &#123; foods: [ &#123; id: 1, name: &#x27;原味鱿鱼丝&#x27;, image: &#x27;./images/原味鱿鱼丝.png&#x27;, purchased: false &#125;, &#123; id: 2, name: &#x27;辣味鱿鱼丝&#x27;, image: &#x27;./images/辣味鱿鱼丝.png&#x27;, purchased: false &#125;, &#123; id: 3, name: &#x27;炭烧味鱿鱼丝&#x27;, image: &#x27;./images/炭烧味鱿鱼丝.png&#x27;, purchased: false &#125; ] &#125; &#125;,&#125;).mount(&#x27;#app&#x27;) 随后便可以在那个绑定的div中使用基础vue语法。 并且这里的对象不只有data方法，还有若干别的方法，方便拆分管理 3、v-for v-bind v-modelv-for 指令v-for 用于渲染列表，基本语法如下： 123&lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/li&gt;&lt;/ul&gt; v-for 会遍历 items 数组，并为每个元素生成一个 &lt;li&gt; 元素。每个元素都通过 item 变量可以在模板中访问。key 属性是必需的，用于提高 Vue 追踪每个节点的能力，从而提高渲染性能。 v-bind 指令v-bind 用于绑定元素属性，基本语法如下： 1&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; v-bind 将元素的 disabled 属性绑定到 Vue 实例的 isButtonDisabled 属性。如果 isButtonDisabled 属性的值是 true，则按钮会被禁用。它常用来动态设置 HTML 属性。 简写形式是 :： 1&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 非常常用的是绑定数据，还有绑定class类名 v-model 指令v-model 用于实现双向数据绑定，基本语法如下： 1&lt;input v-model=&quot;message&quot; /&gt; v-model 将 input 的 value 属性和 input 的 oninput 事件绑定到 Vue 实例的 message 属性。这样当 input 值发生变化时，message 属性也会随之更新；反之亦然。 v-model 是 Vue 提供的一种特殊语法糖，本质上它是 v-bind 和 v-on 的结合。 4、v-on v-ifv-on 指令能在html上绑定方法。所绑定的方法写在App对象里的methods属性里。比如 1&lt;form v-on:submit=&quot;add&quot;&gt;&lt;/form&gt; 可以缩写成@。然后再加上form表单触发submit事件的时候默认会刷新页面，但是我们不需要它提交表单，所以用vue提供的方法之间阻止，写成： 1&lt;form @submit.prevent=&quot;add&quot;&gt;&lt;/form&gt; v-if 指令就是把js能做的判断能写到html标签里，如果满足才显示这个标签。比如 1&lt;div v-if=&quot;items.length &gt; 3&quot;&gt;&lt;/div&gt; 满足items的长度的时候才显示这个div标签 还有v-else-if与v-else可以用，不过多赘述 5、拆分组件这是vue最核心的思想。比如首先可以把基础导入写成Vue.createApp(App).mount(&#39;#app&#39;)，然后就可以新建一个文件App.js，把东西都写在这里。然后使用es6的导出导入语法挂载 在App对象里，添加template属性，属性是反引号字符串，然后就可以把所有之前写在id为app的div里的html写在反引号里了。vue会为我们挂载并使用 6、细化拆分再在这个app.js写多了东西感觉复杂，还能细化拆分。把App对象里的所有东西都删除，只留一个template属性，再加一个components方法，用es6的导入对象，这就是要引入的东西。再新建个文件，写和app.js类似的对象导出。把传入的对象写成html标签写入App的template里，实现了组件进一步细化拆分 7、父子组件通信父传子在父组件的template里，写子组件的html标签时，添加一个属性。比如 1&lt;son :message=&quot;mes1&quot;&gt;&lt;/son&gt; 然后在子组件里添加一个props属性，是个对象，对象里是信息的名加上信息类型，就能传入信息了。比如 12345&#123; props: &#123; mes1: String, &#125;&#125; 子传父使用$emit方法，子组件可以向父组件发送事件。这个方法接收两个参数，第一个参数是事件的名称，第二个参数是随事件一起发送的数据。当子组件调用 $emit 方法时，会触发一个事件，这个事件会向上冒泡到父组件，父组件可以通过 v-on 或者 @ 对这个事件进行监听，并在回调函数中接收数据，完成子组件到父组件的通信。举例： 子组件： 12345678910&#123; template: ` &lt;button @click=&quot;notifyParent&quot;&gt;Click me&lt;/button&gt; ` methods: &#123; notifyParent() &#123; this.$emit(&#x27;childClicked&#x27;, &#x27;Hello, parent!&#x27;); &#125; &#125;&#125; 父组件： 1234567891011121314import ChildComponent from &#x27;./ChildComponent.vue&#x27;;export default &#123; components: &#123; ChildComponent &#125;, template: ` &lt;child-component @childClicked=&quot;handleChildClick&quot;&gt;&lt;/child-component&gt; `, methods: &#123; handleChildClick(message) &#123; console.log(message); // 输出 &#x27;Hello, parent!&#x27; &#125; &#125;&#125; 能够点击子组件按钮，控制台输出Hello, parent! 感觉这个语法比较费解，大致过程是： 首先，在最终要点击的子组件上绑定函数 然后在这个函数上，使用$emit方法，第一个参数是传递的名称，第二个参数是传递的信息。这样做等于是向调用它的人暴露出了第一个参数命名的属性 再然后，在父组件里，导入子组件，在template中使用此组件，并用v-on，父组件的方法监听暴露出来的属性。 这时候，父组件监听函数的定义里参数便是子组件传递的信息（即第二个参数），便能在父组件做一些事情。每当子组件的函数被调用，父组件的监听函数也就跟着被调用，完成了子传父。 二、vue3组合式API基础1、安装运行使用creat-vue脚手架构建(基于Vite) 1npm init vue@latest 2、基本文件结构根目录 index.html是最终入口，最后vue会把东西挂载至此 其他都是一些工程的配置文件 src在这里进行主要代码的书写 App.vue 根组件文件 main.js 项目的入口文件 components文件夹 存放项目使用的公共组件 assets文件夹 存放每个页面对应的css、js公共函数以及图片文件 public公共资源目录 dist存放打包好生成的文件 3、基本使用从App.vue开始vue3使用了组合式语法，简化了vue2的语法。在 &lt;script&gt; 标签内编写JavaScript，&lt;template&gt; 标签内编写HTML。使用双大括号 &#123;&#123; &#125;&#125; 包含变量或语句。 响应式数据使用 reactive() 和 ref() 使HTML中的变量可变，即JavaScript更改变量后，HTML会重新渲染新值。 ref()：创建一个响应式数据对象。ref() 返回的对象包含一个 .value 属性用于获取或设置内部值。 reactive()：接受一个普通对象并返回其代理，等同于 Vue 2.x 的Vue.observable()。 计算属性用于影响响应式数据。定义一个函数来更改响应式数据，得到的结果仍然是响应式的，可以在HTML中实时渲染。 使用 computed() 函数创建计算属性，这个函数接收一个 getter 函数并返回一个不可变的响应式 ref 对象。当依赖的响应式数据发生变化时，getter 函数会自动重新计算。 最好不要传入有副作用的函数。计算属性是只读的 监听使用 watch() 函数监听数据变化，数据发生变化时会触发回调函数。 1watch(xxx, (newVal, oldVal)=&gt;&#123;&#125;) immediate 参数：放在最后，如果指定了这个参数，将首先立即执行一次回调函数。 默认为浅层监听，即如果监听的是一个对象，对象的属性发生变化不会调用回调函数。如果要进行深度监听，需要指定 deep 参数。 如果需要精确监听某个属性，可以将回调函数改写为两个，第一个返回需要监听的属性。 生命周期函数 onBeforeMount(): 在挂载开始之前调用。 onMounted(): 在组件挂载到 DOM 后调用，可以访问和操作 DOM 元素。 onBeforeUpdate(): 在数据更新，导致的虚拟 DOM 重新渲染和打补丁之前调用。 onUpdated(): 在组件 DOM 已经更新，即数据的更改已经体现在 DOM 中之后调用。 onBeforeUnmount(): 新的生命周期函数，在组件卸载之前被调用，可以进行一些清理工作。 onUnmounted(): 在组件卸载并从 DOM 中移除后被调用。 注意： beforeCreate 和 created 在 Vue 3 的组合式 API 中没有直接的等价物。 组件父子通信 父传子：在调用子组件时，添加一个属性，即要传递的信息。子组件使用 defineProps() 来接收。如果是响应式数据，需要在添加属性时前面加一个冒号 :。 子传父：在父组件中定义变量，然后在使用子组件时添加一个属性来传递，子组件使用后可以传递信息。注意，使用子组件时需要在方法前加 @，然后子组件通过 defineEmits() 函数来生成传递方法。 模板引用为了获取DOM组件。 首先调用 ref() 函数，传入 null，然后在模板HTML中，用 ref 属性绑定该变量。这样我们就可以通过这个变量获取到DOM。注意，需要在组件挂载完成后才能获取，所以要在 onMounted 生命周期或者之后。 跨层传递数据层组件使用 provide() 函数提供数据，provide(&#39;别名&#39;, 数据)。 底层组件使用 inject() 函数获取数据，inject(&#39;别名&#39;)。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.me/tags/vue/"},{"name":"自学","slug":"自学","permalink":"http://wishao.me/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"紧急事件","slug":"紧急事件","date":"2023-07-09T18:08:30.000Z","updated":"2023-07-10T14:25:29.639Z","comments":true,"path":"2023/07/10/紧急事件/","link":"","permalink":"http://wishao.me/2023/07/10/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"晚上才看见暑假里要每日写总结传博客，遂急忙搭建此站。目前一切都是临时的，后面再做理会。大改的东西有很多，顶部栏完全没弄，访问统计也没弄，友链，关于我之类的都还没，纯毛坯房，后面再加","categories":[{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.me/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[{"name":"紧急事件","slug":"紧急事件","permalink":"http://wishao.me/tags/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/"}],"author":"WiSHao"},{"title":"Hello World","slug":"hello-world","date":"2023-07-09T13:00:00.000Z","updated":"2023-07-10T14:28:30.274Z","comments":true,"path":"2023/07/09/hello-world/","link":"","permalink":"http://wishao.me/2023/07/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.me/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[],"author":"volantis"}],"categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"name":"八股文","slug":"web前端/八股文","permalink":"http://wishao.me/categories/web%E5%89%8D%E7%AB%AF/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.me/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.me/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.me/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"拾遗","slug":"拾遗","permalink":"http://wishao.me/tags/%E6%8B%BE%E9%81%97/"},{"name":"暑假培训","slug":"暑假培训","permalink":"http://wishao.me/tags/%E6%9A%91%E5%81%87%E5%9F%B9%E8%AE%AD/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.me/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"},{"name":"vue","slug":"vue","permalink":"http://wishao.me/tags/vue/"},{"name":"自学","slug":"自学","permalink":"http://wishao.me/tags/%E8%87%AA%E5%AD%A6/"},{"name":"八股文","slug":"八股文","permalink":"http://wishao.me/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"紧急事件","slug":"紧急事件","permalink":"http://wishao.me/tags/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/"}]}