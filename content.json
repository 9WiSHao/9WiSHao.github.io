{"meta":{"title":"WiSHao'blog","subtitle":"WiSHao的博客","description":"终于开始记点东西","author":"WiSHao","url":"http://wishao.fun","root":"/"},"pages":[{"title":"","date":"2025-04-06T07:24:33.836Z","updated":"2023-07-11T01:55:09.000Z","comments":true,"path":"404.html","permalink":"http://wishao.fun/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-04-06T07:24:33.836Z","updated":"2025-04-06T03:54:38.758Z","comments":true,"path":"about/index.html","permalink":"http://wishao.fun/about/index.html","excerpt":"","text":"我 前端从业者 目前就职腾讯 会一点电吉他，不过整个大学期间都没组过乐队 啥都会一点，啥都不精 音游人，这是我的osu主页，主玩戳泡泡，球球osu大申带带 碎碎念虽说自高中毕业的暑假就想搭建自己的博客了，但是初期实在是技术不足，连教程看着都费劲，就不了了之。后来学习了一些知识，却深陷我的强迫症，找不到我满意的主题。就像历史上许多重大事件都是由意外推动的一样，某天有不可抗力突然给了我一晚上的限制让我必须搭建好我的博客，我居然在几小时内完成了主题的挑选，不可思议。 差不多就这样了，或许我写的东西会很水，无所谓了，反正没人看，有个地方放点东西也挺好，也没想给谁看。如果你无意间翻看到了我的博客，恭喜你，有缘人，或许可以加一下我的社交账号？"},{"title":"所有分类","date":"2025-04-06T07:24:33.837Z","updated":"2023-07-10T14:22:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://wishao.fun/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2025-04-06T07:24:33.837Z","updated":"2023-07-10T13:32:53.000Z","comments":true,"path":"friends/index.html","permalink":"http://wishao.fun/friends/index.html","excerpt":"","text":"欢迎捧场"},{"title":"所有标签","date":"2025-04-06T07:24:33.837Z","updated":"2023-07-10T13:42:32.000Z","comments":true,"path":"tags/index.html","permalink":"http://wishao.fun/tags/index.html","excerpt":"","text":"点击查看含此标签的文章"}],"posts":[{"title":"monkey.ts 手搓解释器 - 1.词法分析器、repl","slug":"monkey-ts-手搓解释器-1-词法分析器、repl","date":"2025-04-12T13:32:29.000Z","updated":"2025-04-14T14:32:18.711Z","comments":true,"path":"2025/04/12/monkey-ts-手搓解释器-1-词法分析器、repl/","link":"","permalink":"http://wishao.fun/2025/04/12/monkey-ts-%E6%89%8B%E6%90%93%E8%A7%A3%E9%87%8A%E5%99%A8-1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E3%80%81repl/","excerpt":"使用TypeScript完成一个monkey语言解释器原版书籍为用Go语言自制解释器根据b站up主Snow-原青阳的js版学习更改而成","text":"使用TypeScript完成一个monkey语言解释器原版书籍为用Go语言自制解释器根据b站up主Snow-原青阳的js版学习更改而成 前言实现了词法分析器和REPL 词法分析器1 定义词法单元只是一些常量和类型定义见 token.ts 1234567891011121314151617181920212223242526272829303132export enum TokenType &#123; ILLEGAL = &#x27;ILLEGAL&#x27;, EOF = &#x27;EOF&#x27;, // 标识符+字面量 IDENT = &#x27;IDENT&#x27;, // add, foobar, x, y, ... INT = &#x27;INT&#x27;, // 1343456 // 运算符 ASSIGN = &#x27;=&#x27;, PLUS = &#x27;+&#x27;, // 分隔符 COMMA = &#x27;,&#x27;, SEMICOLON = &#x27;;&#x27;, LPAREN = &#x27;(&#x27;, RPAREN = &#x27;)&#x27;, LBRACE = &#x27;&#123;&#x27;, RBRACE = &#x27;&#125;&#x27;, // 关键字 FUNCTION = &#x27;FUNCTION&#x27;, LET = &#x27;LET&#x27;,&#125;export class Token &#123; constructor(public type: TokenType, public literal: string) &#123;&#125; toString(): string &#123; return `Token($&#123;this.type&#125;, $&#123;this.literal&#125;)`; &#125;&#125; 2 单元测试函数初步写一个测试函数，测试词法分析器是否能正确的将源代码转换为词法单元结构很简单，定义输入的字符串和答案数组，然后遍历验证是不是正确见 test&#x2F;lexer.test.ts 1234567891011121314151617181920212223242526272829303132333435363738import &#123; TokenType &#125; from &#x27;../src/token&#x27;;import &#123; Lexer &#125; from &#x27;../src/lexer&#x27;;function TestNextToken() &#123; const input = &#x27;=+()&#123;&#125;,;&#x27;; const tests: &#123; expectedType: TokenType; expectedLiteral: string; &#125;[] = [ &#123; expectedType: TokenType.ASSIGN, expectedLiteral: &#x27;=&#x27; &#125;, &#123; expectedType: TokenType.PLUS, expectedLiteral: &#x27;+&#x27; &#125;, &#123; expectedType: TokenType.LPAREN, expectedLiteral: &#x27;(&#x27; &#125;, &#123; expectedType: TokenType.RPAREN, expectedLiteral: &#x27;)&#x27; &#125;, &#123; expectedType: TokenType.LBRACE, expectedLiteral: &#x27;&#123;&#x27; &#125;, &#123; expectedType: TokenType.RBRACE, expectedLiteral: &#x27;&#125;&#x27; &#125;, &#123; expectedType: TokenType.COMMA, expectedLiteral: &#x27;,&#x27; &#125;, &#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;, &#123; expectedType: TokenType.EOF, expectedLiteral: &#x27;&#x27; &#125;, ]; const l = new Lexer(input); tests.forEach((tt, i) =&gt; &#123; const tok = l.nextToken(); if (tok.type !== tt.expectedType) &#123; console.error(`tests[$&#123;i&#125;] - tokentype wrong. expected=$&#123;tt.expectedType&#125;, got=$&#123;tok.type&#125;`); &#125; if (tok.literal !== tt.expectedLiteral) &#123; console.error(`tests[$&#123;i&#125;] - literal wrong. expected=$&#123;tt.expectedLiteral&#125;, got=$&#123;tok.literal&#125;`); &#125; &#125;); console.log(&#x27;所有测试用例均测试完成!&#x27;);&#125;// 运行测试TestNextToken(); 3 词法分析1 最基础的特殊符号先简单实现 Lexer 的框架，就是读字符串，然后逐个转换成 token 里定义的 enum。主要是实现基础功能，比如一些状态，下一个的函数之类的，只添加了对基础的特殊符号识别见 lexer.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; Token, TokenType &#125; from &#x27;./token&#x27;;export class Lexer &#123; input: string; // 输入的字符串 position: number = 0; // 所输入字符串中的当前位置（指向当前字符） readPosition: number = 0; // 所输入字符串中的当前读取位置（指向当前字符之后的一个字符） ch: string | undefined; // 当前正在查看的字符 constructor(input: string) &#123; this.input = input; this.readChar(); &#125; readChar = () =&gt; &#123; if (this.readPosition &gt;= this.input.length) &#123; this.ch = undefined; &#125; else &#123; this.ch = this.input[this.readPosition]; &#125; this.position = this.readPosition; this.readPosition++; &#125;; nextToken = (): Token =&gt; &#123; let tok: Token; switch (this.ch) &#123; case &#x27;=&#x27;: tok = new Token(TokenType.ASSIGN, this.ch); break; case &#x27;;&#x27;: tok = new Token(TokenType.SEMICOLON, this.ch); break; case &#x27;(&#x27;: tok = new Token(TokenType.LPAREN, this.ch); break; case &#x27;)&#x27;: tok = new Token(TokenType.RPAREN, this.ch); break; case &#x27;,&#x27;: tok = new Token(TokenType.COMMA, this.ch); break; case &#x27;+&#x27;: tok = new Token(TokenType.PLUS, this.ch); break; case &#x27;&#123;&#x27;: tok = new Token(TokenType.LBRACE, this.ch); break; case &#x27;&#125;&#x27;: tok = new Token(TokenType.RBRACE, this.ch); break; case undefined: tok = new Token(TokenType.EOF, &#x27;&#x27;); break; default: tok = new Token(TokenType.ILLEGAL, &lt;any&gt;this.ch); break; &#125; this.readChar(); return tok; &#125;;&#125; 然后npm run test运行测试，打印所有测试用例均测试完成!，并且前面没有任何错误打印，说明简单的Lexer完成 4 词法分析2 简单关键字和数字、空格实现更复杂的token转换。比如多字符关键字，空格，回车等这里先实现let fn两个关键字和数字，以及用户的自定义变量 先把测试函数里的输入和答案数组改了见 test&#x2F;lexer.test.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const input = ` let five = 5; let ten = 10; let add = fn(x, y) &#123; x + y; &#125;; let result = add(five, ten);`;const tests: &#123; expectedType: TokenType; expectedLiteral: string;&#125;[] = [ &#123; expectedType: TokenType.LET, expectedLiteral: &#x27;let&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;five&#x27; &#125;, &#123; expectedType: TokenType.ASSIGN, expectedLiteral: &#x27;=&#x27; &#125;, &#123; expectedType: TokenType.INT, expectedLiteral: &#x27;5&#x27; &#125;, &#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;, &#123; expectedType: TokenType.LET, expectedLiteral: &#x27;let&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;ten&#x27; &#125;, &#123; expectedType: TokenType.ASSIGN, expectedLiteral: &#x27;=&#x27; &#125;, &#123; expectedType: TokenType.INT, expectedLiteral: &#x27;10&#x27; &#125;, &#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;, &#123; expectedType: TokenType.LET, expectedLiteral: &#x27;let&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;add&#x27; &#125;, &#123; expectedType: TokenType.ASSIGN, expectedLiteral: &#x27;=&#x27; &#125;, &#123; expectedType: TokenType.FUNCTION, expectedLiteral: &#x27;fn&#x27; &#125;, &#123; expectedType: TokenType.LPAREN, expectedLiteral: &#x27;(&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;x&#x27; &#125;, &#123; expectedType: TokenType.COMMA, expectedLiteral: &#x27;,&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;y&#x27; &#125;, &#123; expectedType: TokenType.RPAREN, expectedLiteral: &#x27;)&#x27; &#125;, &#123; expectedType: TokenType.LBRACE, expectedLiteral: &#x27;&#123;&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;x&#x27; &#125;, &#123; expectedType: TokenType.PLUS, expectedLiteral: &#x27;+&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;y&#x27; &#125;, &#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;, &#123; expectedType: TokenType.RBRACE, expectedLiteral: &#x27;&#125;&#x27; &#125;, &#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;, &#123; expectedType: TokenType.LET, expectedLiteral: &#x27;let&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;result&#x27; &#125;, &#123; expectedType: TokenType.ASSIGN, expectedLiteral: &#x27;=&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;add&#x27; &#125;, &#123; expectedType: TokenType.LPAREN, expectedLiteral: &#x27;(&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;five&#x27; &#125;, &#123; expectedType: TokenType.COMMA, expectedLiteral: &#x27;,&#x27; &#125;, &#123; expectedType: TokenType.IDENT, expectedLiteral: &#x27;ten&#x27; &#125;, &#123; expectedType: TokenType.RPAREN, expectedLiteral: &#x27;)&#x27; &#125;, &#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;, &#123; expectedType: TokenType.EOF, expectedLiteral: &#x27;&#x27; &#125;,]; 这时候肯定是通过不了测试。需要继续完善lexer先完善token.ts，添加关键字的映射见token.ts 1234567891011const keywordIdentMap = new Map&lt;string, TokenType&gt;([ [&#x27;fn&#x27;, TokenType.FUNCTION], [&#x27;let&#x27;, TokenType.LET],]);export function lookupIdent(ident: string) &#123; if (keywordIdentMap.has(ident)) &#123; return keywordIdentMap.get(ident) as TokenType; &#125; return TokenType.IDENT;&#125; 然后扩展switch语句，用以识别关键字和标识符，数字并且需要跳过空白字符见lexer.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061nextToken = (): Token =&gt; &#123; let tok: Token; this.skipWhitespace(); switch (this.ch) &#123; /**其他switch部分和前面一样，略过 */ default: if (this.isLetter(this.ch)) &#123; const _literal = this.readIdentifier(); const _type = lookupIdent(_literal); tok = new Token(_type, _literal); // 这里必须提前返回，因为readIdentifier里已经调readChar了，不要再调一次 return tok; &#125; else if (this.isDigit(this.ch)) &#123; const _literal = this.readNumber(); tok = new Token(TokenType.INT, _literal); return tok; &#125; else &#123; tok = new Token(TokenType.ILLEGAL, this.ch); &#125; break; &#125; this.readChar(); return tok;&#125;;readIdentifier = () =&gt; &#123; const start = this.position; while (this.ch &amp;&amp; this.isLetter(this.ch)) &#123; this.readChar(); &#125; return this.input.slice(start, this.position);&#125;;isLetter = (char: string) =&gt; /[a-zA-Z_]/.test(char);skipWhitespace = () =&gt; &#123; while (this.ch &amp;&amp; /[ \\t\\n\\r]/.test(this.ch)) &#123; this.readChar(); &#125;&#125;;readNumber = () =&gt; &#123; const start = this.position; while (this.ch &amp;&amp; this.isDigit(this.ch)) &#123; this.readChar(); &#125; return this.input.slice(start, this.position);&#125;;isDigit = (char: string) =&gt; char &gt;= &#x27;0&#x27; &amp;&amp; char &lt;= &#x27;9&#x27;;readChar = () =&gt; &#123; if (this.readPosition &gt;= this.input.length) &#123; this.ch = undefined; &#125; else &#123; this.ch = this.input[this.readPosition]; &#125; this.position = this.readPosition; this.readPosition++;&#125;; 然后npm run test运行测试这时发现我们的简单测试用例 123456let five = 5; let ten = 10; let add = fn(x, y) &#123; x + y; &#125;;let result = add(five, ten); 能通过了，成功识别了用户的变量以及数字、let fn关键字 4 词法分析3 剩下的全部关键字接下来是剩下的关键字。双字符的&#x3D;&#x3D;复杂一点，剩下的关键字true false return之类的，以及+-*&#x2F;之类的运算符和前面一样 测试用例加上这几个见 test&#x2F;lexer.test.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** 前略 */! - / * 5; 5 &lt; 10 &gt; 5;if (5 &lt; 10) &#123; return true;&#125; else &#123; return false; &#125;10 == 10;10 != 9;&#123; expectedType: TokenType.BANG, expectedLiteral: &#x27;!&#x27; &#125;,&#123; expectedType: TokenType.MINUS, expectedLiteral: &#x27;-&#x27; &#125;,&#123; expectedType: TokenType.SLASH, expectedLiteral: &#x27;/&#x27; &#125;,&#123; expectedType: TokenType.ASTERISK, expectedLiteral: &#x27;*&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;5&#x27; &#125;,&#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;5&#x27; &#125;,&#123; expectedType: TokenType.LT, expectedLiteral: &#x27;&lt;&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;10&#x27; &#125;,&#123; expectedType: TokenType.GT, expectedLiteral: &#x27;&gt;&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;5&#x27; &#125;,&#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;,&#123; expectedType: TokenType.IF, expectedLiteral: &#x27;if&#x27; &#125;,&#123; expectedType: TokenType.LPAREN, expectedLiteral: &#x27;(&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;5&#x27; &#125;,&#123; expectedType: TokenType.LT, expectedLiteral: &#x27;&lt;&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;10&#x27; &#125;,&#123; expectedType: TokenType.RPAREN, expectedLiteral: &#x27;)&#x27; &#125;,&#123; expectedType: TokenType.LBRACE, expectedLiteral: &#x27;&#123;&#x27; &#125;,&#123; expectedType: TokenType.RETURN, expectedLiteral: &#x27;return&#x27; &#125;,&#123; expectedType: TokenType.TRUE, expectedLiteral: &#x27;true&#x27; &#125;,&#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;,&#123; expectedType: TokenType.RBRACE, expectedLiteral: &#x27;&#125;&#x27; &#125;,&#123; expectedType: TokenType.ELSE, expectedLiteral: &#x27;else&#x27; &#125;,&#123; expectedType: TokenType.LBRACE, expectedLiteral: &#x27;&#123;&#x27; &#125;,&#123; expectedType: TokenType.RETURN, expectedLiteral: &#x27;return&#x27; &#125;,&#123; expectedType: TokenType.FALSE, expectedLiteral: &#x27;false&#x27; &#125;,&#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;,&#123; expectedType: TokenType.RBRACE, expectedLiteral: &#x27;&#125;&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;10&#x27; &#125;,&#123; expectedType: TokenType.EQ, expectedLiteral: &#x27;==&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;10&#x27; &#125;,&#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;10&#x27; &#125;,&#123; expectedType: TokenType.NOT_EQ, expectedLiteral: &#x27;!=&#x27; &#125;,&#123; expectedType: TokenType.INT, expectedLiteral: &#x27;9&#x27; &#125;,&#123; expectedType: TokenType.SEMICOLON, expectedLiteral: &#x27;;&#x27; &#125;,&#123; expectedType: TokenType.EOF, expectedLiteral: &#x27;&#x27; &#125;,/** 后略 */ 在token.ts里添加这些关键字的映射 见token.ts 1234567891011121314151617181920212223242526MINUS = &#x27;-&#x27;,BANG = &#x27;!&#x27;,ASTERISK = &#x27;*&#x27;,SLASH = &#x27;/&#x27;,LT = &#x27;&lt;&#x27;,GT = &#x27;&gt;&#x27;,EQ = &#x27;==&#x27;,NOT_EQ = &#x27;!=&#x27;,TRUE = &#x27;TRUE&#x27;,FALSE = &#x27;FALSE&#x27;,IF = &#x27;IF&#x27;,ELSE = &#x27;ELSE&#x27;,RETURN = &#x27;RETURN&#x27;,/** 中间略 */const keywordIdentMap = new Map&lt;string, TokenType&gt;([ [&#x27;fn&#x27;, TokenType.FUNCTION], [&#x27;let&#x27;, TokenType.LET], [&#x27;true&#x27;, TokenType.TRUE], [&#x27;false&#x27;, TokenType.FALSE], [&#x27;if&#x27;, TokenType.IF], [&#x27;else&#x27;, TokenType.ELSE], [&#x27;return&#x27;, TokenType.RETURN],]); 然后在lexer.ts的switch里简单添加上这些的识别就行了，和前面基本一样。不一样的就是这个双字符的关键字&#x3D;&#x3D;和!&#x3D;，单独处理一些即可，用了个peekChar函数预读下一个字符见lexer.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 case &#x27;=&#x27;: // 是==的情况 if (this.peekChar() === &#x27;=&#x27;) &#123; const _ch = this.ch; this.readChar(); const _literal = _ch + this.ch; tok = new Token(TokenType.EQ, _literal); break; &#125; tok = new Token(TokenType.ASSIGN, this.ch); break;/** 后略 */case &#x27;-&#x27;: tok = new Token(TokenType.MINUS, this.ch); break;case &#x27;!&#x27;: // 是!=的情况 if (this.peekChar() === &#x27;=&#x27;) &#123; const _ch = this.ch; this.readChar(); const _literal = _ch + this.ch; tok = new Token(TokenType.NOT_EQ, _literal); break; &#125; tok = new Token(TokenType.BANG, this.ch); break;case &#x27;*&#x27;: tok = new Token(TokenType.ASTERISK, this.ch); break;case &#x27;/&#x27;: tok = new Token(TokenType.SLASH, this.ch); break;case &#x27;&lt;&#x27;: tok = new Token(TokenType.LT, this.ch); break;case &#x27;&gt;&#x27;: tok = new Token(TokenType.GT, this.ch); break;/** 后略 */// 向后预读一个字符，为的是双字符关键字比如==peekChar = () =&gt; &#123; if (this.readPosition &gt;= this.input.length) &#123; return; &#125; return this.input[this.readPosition];&#125;; 改完之后运行npm run test，测试没有报错均通过，完成这部分的编写 REPL1 什么是REPLREPL是Read-Eval-Print Loop的缩写，顾名思义就是读入一行代码，执行它，然后打印结果。对用户来说直观来看就是一个控制台，方便用户交互用的。用户输入它就执行，输出结果实现上来看，就是一个死循环里用node的readline模块，监听用户输入的文本，按到回车就执行，然后输出结果，开始下一轮 2 REPL实现虽然说现在只是实现了源码转token的词法分析器，但是我们可以先实现一个简单的REPL，先把token打印出来，看看我们词法分析器是否正确下面实现一下。见repl.ts 12345678910111213141516171819202122232425262728293031323334import &#123; createInterface &#125; from &#x27;readline&#x27;;import os from &#x27;os&#x27;;import process from &#x27;process&#x27;;import &#123; Lexer &#125; from &#x27;./lexer&#x27;;import &#123; TokenType &#125; from &#x27;./token&#x27;;const username = os.userInfo().username;const PROMPT = &#x27;&gt;&gt; &#x27;;const rl = createInterface(&#123; input: process.stdin, output: process.stdout, prompt: PROMPT,&#125;);function startRepl() &#123; console.log(`Hello $&#123;username&#125;! This is the Monkey programming language!`); console.log(&#x27;Feel free to type in commands&#x27;); rl.prompt(); rl.on(&#x27;line&#x27;, (line) =&gt; &#123; const lexer = new Lexer(line); let token = lexer.nextToken(); while (token.type !== TokenType.EOF) &#123; process.stdout.write(`$&#123;JSON.stringify(token)&#125;\\n`); token = lexer.nextToken(); &#125; rl.prompt(); &#125;); rl.on(&#x27;close&#x27;, () =&gt; &#123; process.stdout.write(&#x27;\\nExiting REPL.\\n&#x27;); &#125;);&#125;startRepl(); 然后为了方便，在package.json里加上一个命令 123&quot;scripts&quot;: &#123; &quot;repl&quot;: &quot;npx tsx src/repl.ts&quot;&#125; 运行npm run repl，打开repl。试着输入一些monkey的代码，比如let a = 1; fn abc(a, b) &#123; return a + b; &#125;;看看能不能正确的打印出token 结果是正确打印如下 123456789101112131415161718192021222324252627282930npm run repl&gt; monkey.ts@1.0.0 repl&gt; npx tsx src/repl.tsHello WiSHao! This is the Monkey programming language!Feel free to type in commands&gt;&gt; let a = 1; fn abc(a, b) &#123; return a + b; &#125;;&#123;&quot;type&quot;:&quot;LET&quot;,&quot;literal&quot;:&quot;let&quot;&#125;&#123;&quot;type&quot;:&quot;IDENT&quot;,&quot;literal&quot;:&quot;a&quot;&#125;&#123;&quot;type&quot;:&quot;=&quot;,&quot;literal&quot;:&quot;=&quot;&#125;&#123;&quot;type&quot;:&quot;INT&quot;,&quot;literal&quot;:&quot;1&quot;&#125;&#123;&quot;type&quot;:&quot;;&quot;,&quot;literal&quot;:&quot;;&quot;&#125;&#123;&quot;type&quot;:&quot;FUNCTION&quot;,&quot;literal&quot;:&quot;fn&quot;&#125;&#123;&quot;type&quot;:&quot;IDENT&quot;,&quot;literal&quot;:&quot;abc&quot;&#125;&#123;&quot;type&quot;:&quot;(&quot;,&quot;literal&quot;:&quot;(&quot;&#125;&#123;&quot;type&quot;:&quot;IDENT&quot;,&quot;literal&quot;:&quot;a&quot;&#125;&#123;&quot;type&quot;:&quot;,&quot;,&quot;literal&quot;:&quot;,&quot;&#125;&#123;&quot;type&quot;:&quot;IDENT&quot;,&quot;literal&quot;:&quot;b&quot;&#125;&#123;&quot;type&quot;:&quot;)&quot;,&quot;literal&quot;:&quot;)&quot;&#125;&#123;&quot;type&quot;:&quot;&#123;&quot;,&quot;literal&quot;:&quot;&#123;&quot;&#125;&#123;&quot;type&quot;:&quot;RETURN&quot;,&quot;literal&quot;:&quot;return&quot;&#125;&#123;&quot;type&quot;:&quot;IDENT&quot;,&quot;literal&quot;:&quot;a&quot;&#125;&#123;&quot;type&quot;:&quot;+&quot;,&quot;literal&quot;:&quot;+&quot;&#125;&#123;&quot;type&quot;:&quot;IDENT&quot;,&quot;literal&quot;:&quot;b&quot;&#125;&#123;&quot;type&quot;:&quot;;&quot;,&quot;literal&quot;:&quot;;&quot;&#125;&#123;&quot;type&quot;:&quot;&#125;&quot;,&quot;literal&quot;:&quot;&#125;&quot;&#125;&#123;&quot;type&quot;:&quot;;&quot;,&quot;literal&quot;:&quot;;&quot;&#125;&gt;&gt;Exiting REPL. repl至此完成 结语这次完成了词法分析器和REPL的实现，虽然只是简单的实现了一些功能，但是已经能看出monkey语言的雏形了接下来会继续实现语法分析器","categories":[{"name":"编译原理","slug":"编译原理","permalink":"http://wishao.fun/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"monkey.ts","slug":"编译原理/monkey-ts","permalink":"http://wishao.fun/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/monkey-ts/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.fun/tags/TypeScript/"},{"name":"monkey.ts","slug":"monkey-ts","permalink":"http://wishao.fun/tags/monkey-ts/"},{"name":"编译原理","slug":"编译原理","permalink":"http://wishao.fun/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"monkey.ts 手搓解释器 - 0.缘起","slug":"monkey-ts-手搓解释器-0-缘起","date":"2025-04-11T05:15:22.000Z","updated":"2025-04-11T14:40:21.182Z","comments":true,"path":"2025/04/11/monkey-ts-手搓解释器-0-缘起/","link":"","permalink":"http://wishao.fun/2025/04/11/monkey-ts-%E6%89%8B%E6%90%93%E8%A7%A3%E9%87%8A%E5%99%A8-0-%E7%BC%98%E8%B5%B7/","excerpt":"使用TypeScript完成一个monkey语言解释器原版书籍为用Go语言自制解释器根据b站up主Snow-原青阳的js版学习更改而成","text":"使用TypeScript完成一个monkey语言解释器原版书籍为用Go语言自制解释器根据b站up主Snow-原青阳的js版学习更改而成 前言缘起一直觉得编译器非常神奇，虽然本科期间在学校里学过编译原理的课程，但是感觉我实属是面向考试学习。并且由于当时的课程要求不高，并没有让我们从零手搓一个编译器，我感觉我只是学了点做题技巧，而没能窥见编译器的全貌。某天很幸运在刷视频的时候看到有个 up 做了个用 js 实现解释器的视频，感觉太对了，这正是我想要的，用我最熟的语言实现一个解释器，这简直太酷了于是接下来我决定追完这系列视频，完成这个项目，顺便记录一下我的学习过程 目标用 js TS 自制一个 monkey 语言解释器，不使用任何外部库。这是个简单的脚本语言，包含大部分编程语言的基础内容，实现它已经够了解解释器原理了教程来自于b 站 up 主 Snow-原青阳的视频他使用 js 完成，并且推荐有能力的改用 ts 完成，我觉得完全可以，就换 ts 完成(联想到 ts 团队正在把 ts 的编译器无缝迁移到 go 语言上，我现在居然在反向做) 梳理monkey 语言一门作者为这本书的学习自创的简单语言，麻雀虽小五脏俱全，有以下特性 类C语法 变量绑定 整型和布尔型 算术表达式 内置函数 头等函数和高阶函数 闭包 字符串数据结构 数组数据结构 哈希数据结构 最终目标就是实现这个语言的解释器 脉络编译原理：源代码文本 –&gt; 词法分析 –&gt; 语法分析 –&gt; 抽象语法树 –&gt; 求值 –&gt; 结果最终为这门语言实现的是一个树遍历解释器，所以没有那么复杂 初始化项目起步由于用的ts实现，所以需要node环境。先npm init -y初始化一个node项目，自己简单配一下之后安装 typescript 和 tsx，用来编译和运行 ts 代码 配置 tsconfig.json（按自己喜欢风格来之后就可以直接用 npx tsx xxx.ts 运行 ts 文件了 为了省事直接在scripts里加上npx tsx test/lexer.test.ts，直接npm run test就能跑单元测试除此之外不需要任何其他依赖，这个项目就是希望尽量少用依赖，完整体验整个过程","categories":[{"name":"编译原理","slug":"编译原理","permalink":"http://wishao.fun/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"monkey.ts","slug":"编译原理/monkey-ts","permalink":"http://wishao.fun/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/monkey-ts/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.fun/tags/TypeScript/"},{"name":"monkey.ts","slug":"monkey-ts","permalink":"http://wishao.fun/tags/monkey-ts/"},{"name":"编译原理","slug":"编译原理","permalink":"http://wishao.fun/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"腾笼换鸟：Pterodactyl面板无neoforge预设的neoforge minecraft服务端安装法","slug":"腾笼换鸟：Pterodactyl面板无neoforge预设的neoforge-minecraft服务器安装法","date":"2025-03-08T03:11:59.000Z","updated":"2025-04-11T14:38:33.617Z","comments":true,"path":"2025/03/08/腾笼换鸟：Pterodactyl面板无neoforge预设的neoforge-minecraft服务器安装法/","link":"","permalink":"http://wishao.fun/2025/03/08/%E8%85%BE%E7%AC%BC%E6%8D%A2%E9%B8%9F%EF%BC%9APterodactyl%E9%9D%A2%E6%9D%BF%E6%97%A0neoforge%E9%A2%84%E8%AE%BE%E7%9A%84neoforge-minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E6%B3%95/","excerpt":"想开 neoforge 服务器和朋友玩机械动力最新 6.0，但是发现翼龙面板里没 neoforge 预设。作为一个只会面板一键开服的新手，折腾出来了 Pterodactyl 翼龙面板开我的世界 neoforge 服务端方法。记录一下，里面还有各种坑，懒得配图了。","text":"想开 neoforge 服务器和朋友玩机械动力最新 6.0，但是发现翼龙面板里没 neoforge 预设。作为一个只会面板一键开服的新手，折腾出来了 Pterodactyl 翼龙面板开我的世界 neoforge 服务端方法。记录一下，里面还有各种坑，懒得配图了。 背景目标使用 Pterodactyl 翼龙面板开最新 1.21.1 neoforge 的 minecraft 服务器，装最新 create 机械动力 6.0.0 mod 和朋友一块玩。 现有条件 腾讯云服务器一台，带公网 ip，已经预装翼龙面板 此前有翼龙面板一键开服经验，带的预设搞明白了怎么开服（比如自带的 paper，forge 预设） 懂一定的运维知识 困难其实最终目标是装机械动力 6.0 + 原版 1.21.1 到服务端。但是机械动力 6.0 对 1.21 版本仅支持 neoforge，翼龙面板偏偏没这个预设。但是我又想用面板方便的 gui，所以希望折腾出来用翼龙面板开的方法。（其实最后搞不出来的话我会退一步直接用命令行开的，不过幸好给折腾成功了） 解决思路指导思想腾笼换鸟，先用面板开 forge 预设，然后删除里面的文件换成 neoforge，上传 mod 和存档，更改面板启动命令，完成开服。 具体实现 由于 java 的优秀移植性，jar 文件到什么系统都一样用，所以我先选择了我熟悉的自己电脑，到官网下载好 neoforge 对应版本 jar 包，启动安装一个 server 端。 然后把 eula.txt 改成 true 同意了，打成 tar 包。 到翼龙面板上，使用 forge 预设开一个 minecraft 服务器。像往常使用面板一样开就行了。 开完不要启动，放那。 用 ssh 工具连上服务器，找到翼龙面板刚才开 forge 预设的地方，把里面东西除了 server.properties 全删了，然后用 ftp 把之前打的 neoforge 的服务端 tar 包传上去。传上去解压。 现在可以到面板的文件管理这里了，我感觉比 ssh 的 ftp 工具方便。在这把 world 文件夹换成你想搞的存档，mods 文件夹里上传一下机械动力的 jar 包，完成腾笼换鸟操作。 到面板控制台启动服务器，看到 log 都挺正常，开机成功。 实验一下，打开自己装同样 neoforge 和 mod 的客户端，多人游戏填服务器 ip 端口，加入游戏成功。合成了一下安山合金成功。 至此完成！ 踩坑本机上 neoforge 安装服务端不成功 双击 jar 文件打不开安装界面，电脑需要安装 java，我用的 java21，还要设置 windows 的环境变量 然后到 powershell 命令行里用 java -jar xxxx.jar命令启动安装界面 安装大概率失败，因为走的国外，要有代理。 根据自己的情况，用命令设置 java 的代理安装，我用的 clash 命令如下 1java -D&quot;http.proxyHost=127.0.0.1&quot; -D&quot;http.proxyPort=7891&quot; -D&quot;https.proxyHost=127.0.0.1&quot; -D&quot;https.proxyPort=7891&quot; -jar neoforge-21.3.58-installer.jar --install-server ftp 用不了 linux 老问题了，ssh 客户端的 ftp 用户没权限。 简单粗暴的方法就是找到你要上传的文件夹，直接给权限，chmod 777 ./xxxx 翼龙面板 forge 预设安装成功，但是启动的时候报内存不足开机失败 其实并不是内存不足，去文件管理页看一下就知道，这里啥也没有，是因为网络原因 forge 压根没装上 没办法，内地服务器是这样的，forge 的服务器在外面连不上 不过完全不是问题，没有也没事，腾笼换鸟嘛，都省腾笼了，直接是空笼子，直接往里上传你新下的 neoforge 服务端就行了 翼龙面板文件管理页传不上去东西 因为默认是限制 100m 大小的文件，并且不能传文件夹。 我没研究怎么在面板上改限制，懒得研究了，直接简单粗暴用自己的 ssh ftp 工具传得了。不能传文件夹就打成 tar 包上去再解压","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"http://wishao.fun/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"minecraft","slug":"瞎折腾/minecraft","permalink":"http://wishao.fun/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/minecraft/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"游戏","slug":"游戏","permalink":"http://wishao.fun/tags/%E6%B8%B8%E6%88%8F/"},{"name":"minecraft","slug":"minecraft","permalink":"http://wishao.fun/tags/minecraft/"},{"name":"neoforge","slug":"neoforge","permalink":"http://wishao.fun/tags/neoforge/"},{"name":"Pterodactyl","slug":"Pterodactyl","permalink":"http://wishao.fun/tags/Pterodactyl/"}]},{"title":"前端手搓还原","slug":"前端手搓还原","date":"2024-03-19T10:24:22.000Z","updated":"2024-03-21T07:22:17.955Z","comments":true,"path":"2024/03/19/前端手搓还原/","link":"","permalink":"http://wishao.fun/2024/03/19/%E5%89%8D%E7%AB%AF%E6%89%8B%E6%90%93%E8%BF%98%E5%8E%9F/","excerpt":"手撕 js 系列","text":"手撕 js 系列 1 手写还原简单 promise简单还原，链式调用和 catch 没写我认为的核心就是 then 函数那，初次调用如果是 pending 状态等待，就把传入的函数收集起来等到调用 resolve 或者 reject 的时候，把收集来的函数再调用，核心就是延迟执行回调函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MyPromise &#123; state: &#x27;pending&#x27; | &#x27;fulfilled&#x27; | &#x27;rejected&#x27; = &#x27;pending&#x27;; result: any; thenFuncs: Array&lt;&#123; done: Function; fail?: Function &#125;&gt; = []; constructor(func: (resolve: Function, reject?: Function) =&gt; void) &#123; try &#123; func(this.resolve, this.reject); &#125; catch (err) &#123; this.reject(err); &#125; &#125; resolve = (arg: any) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;fulfilled&#x27;; this.result = arg; queueMicrotask(() =&gt; &#123; this.thenFuncs.forEach((&#123; done &#125;) =&gt; done(this.result)); this.thenFuncs = []; &#125;); &#125; &#125;; reject = (arg: any) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;rejected&#x27;; this.result = arg; queueMicrotask(() =&gt; &#123; this.thenFuncs.forEach((&#123; fail &#125;) =&gt; fail &amp;&amp; fail(this.result)); this.thenFuncs = []; &#125;); &#125; &#125;; then = (done: (res: any) =&gt; void, fail?: (res: any) =&gt; void) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.thenFuncs.push(&#123; done: done, fail: fail &#125;); &#125; if (this.state === &#x27;fulfilled&#x27;) &#123; queueMicrotask(() =&gt; &#123; done(this.result); &#125;); &#125; if (this.state === &#x27;rejected&#x27;) &#123; queueMicrotask(() =&gt; &#123; if (fail) fail(this.result); &#125;); &#125; &#125;;&#125;console.log(1);let my = new MyPromise((resolve, reject) =&gt; &#123; console.log(2); setTimeout(() =&gt; &#123; resolve(3); &#125;, 1000);&#125;);my.then((res) =&gt; &#123; console.log(res);&#125;); instanceof理解 new 的时候发生什么简单讲就是，构造函数有原型链指向这个构造函数的原型对象（这玩意就是构造函数写的一堆属性之类的）new 出来的对象也会有原型链指向那个原型对象 12345678function myInstanceof(obj, constructor) &#123; let proto = Object.getPrototypeOf(obj); while (proto) &#123; if (proto === constructor.prototype) return true; proto = Object.getPrototypeOf(proto); &#125; return false;&#125; typeof直接用Object.prototype.toString.call()实现得了 12345function myTypeof(value) &#123; const typeStr = Object.prototype.toString.call(value); // 会形如[object Type]，所以取那个type就行了 return typeStr.slice(8, -1).toLowerCase();&#125; 深拷贝 deepClone要处理很多情况，weakmap 处理循环引用，递归解决 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function deepClone(value, hash = new WeakMap()) &#123; const typeStr = Object.prototype.toString.call(value); if (typeStr === &#x27;[object Null]&#x27; || typeStr === &#x27;[object Undefined]&#x27; || typeStr === &#x27;[object String]&#x27; || typeStr === &#x27;[object Number]&#x27; || typeStr === &#x27;[object Boolean]&#x27;) &#123; return value; &#125; if (typeStr === &#x27;[object Date]&#x27;) return new Date(value); if (typeStr === &#x27;[object RegExp]&#x27;) return new RegExp(value); if (hash.has(value)) &#123; return hash.get(value); &#125; if (typeStr === &#x27;[object Set]&#x27;) &#123; let newSet = new Set(); hash.set(value, newSet); value.forEach((item) =&gt; &#123; newSet.add(deepClone(item, hash)); &#125;); return newSet; &#125; if (typeStr === &#x27;[object Map]&#x27;) &#123; let newMap = new Map(); hash.set(value, newMap); value.forEach((mapValue, mapKey) =&gt; &#123; newMap.set(deepClone(mapKey, hash), deepClone(mapValue, hash)); &#125;); return newMap; &#125; if (Array.isArray(value)) &#123; let newArray = []; hash.set(value, newArray); return value.map((item) =&gt; deepClone(item, hash)); &#125; if (typeStr === &#x27;[object Object]&#x27;) &#123; let newObj = &#123;&#125;; hash.set(value, newObj); for (let key of Object.keys(value)) &#123; newObj[key] = deepClone(value[key], hash); &#125; return newObj; &#125; return value;&#125; 手写 new创建一个空对象然后设置成构成函数的原型 1234567function myNew(constructor, ...args) &#123; let obj = &#123;&#125;; Object.setPrototypeOf(obj, constructor.prototype); let result = constructor.apply(obj, args); if (typeof result === &#x27;object&#x27; || typeof result === &#x27;function&#x27;) return result; return obj;&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"原生h5","slug":"原生h5","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fh5/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.fun/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"}]},{"title":"内容高度不定的滑盖动画实现思路","slug":"内容高度不定的滑盖动画实现思路","date":"2024-02-29T05:02:40.000Z","updated":"2024-02-29T07:25:04.773Z","comments":true,"path":"2024/02/29/内容高度不定的滑盖动画实现思路/","link":"","permalink":"http://wishao.fun/2024/02/29/%E5%86%85%E5%AE%B9%E9%AB%98%E5%BA%A6%E4%B8%8D%E5%AE%9A%E7%9A%84%E6%BB%91%E7%9B%96%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/","excerpt":"设计了一个标签页，包括选中的标签和待选的标签。待选标签数量不定，屏幕宽度也不定，所以承载的地方高度不定。希望实现一个盖住待选标签的盖子，能上下滑动，完全盖住待选标签或者露出来","text":"设计了一个标签页，包括选中的标签和待选的标签。待选标签数量不定，屏幕宽度也不定，所以承载的地方高度不定。希望实现一个盖住待选标签的盖子，能上下滑动，完全盖住待选标签或者露出来 前言在做 6657 超级大爆的时候，设计了一个标签选择来筛选分类的页面。标签分为已选和未选，然后下面的具体显示内容作为一个盖子盖住未选标签，盖子可以完全盖住或者完全露出来 大概如原型图所示滑盖未划开，完全盖住待选: 滑盖划开，完全露出待选: 难点在于标签数量不定，屏幕宽度不定导致的换行不定，所以未选标签部分的高度不定那么上面的盖子完全盖住或者露出移动的距离就不定了并且我希望有过渡动画，盖子很丝滑的盖住或者露出。 解决纯 css 行不通一开始想完全用 css 实现，想了半天，不定的话可以把待选和盖子放一个 div 里，切换盖子绝对定位和普通定位的流式布局，来实现盖住或者完全露出 但是这么弄就没过渡动画了，只有某属性的直接变化才能做 translation 过渡 然后想的就是待选标签盒子高度从 0 和 auto 变化，里面东西不能露出外部，这样确实有过渡了，看起来可行但是从内部撑开的 auto 高度没法直接设置，它数值不定弄不了，没有数据驱动的 vue 式方法可用，并且不定的 auto 高度 css 过渡处理不了，css 过渡本质上只能处理固定数值变化 那么看来只能使用操纵 dom 的方式了 这么做的话完全就是原生 h5 的解决方案，我归类成 vue 单纯因为式写 vue 时候遇到的问题 操作 DOM 实现DOM 有个scrollHeight属性，是内部元素实际所占高度。如果溢出或者内部被隐藏也是实际的高度。那么获取装待选标签 div 的scrollHeight，用它和 0px 来回实时赋值 height，css 里写上过渡，就实现了丝滑的滑盖动画意外挺简单 不过注意一下要把待选标签承载盒子的溢出设置为隐藏 大致实现代码12345678910111213&lt;div class=&quot;tags&quot;&gt; &lt;div class=&quot;tag1&quot; v-for=&quot;(item, index) in currentTags&quot; :key=&quot;index&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;meme-and-tag&quot;&gt; &lt;div class=&quot;more-tags&quot; ref=&quot;moreTagsDom&quot;&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tag1&quot; v-for=&quot;(item, index) in moreTags&quot; :key=&quot;index&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;list&quot;&gt; &lt;img class=&quot;handle&quot; src=&quot;@/assets/icon/downArrow.png&quot; @click=&quot;slideList&quot; /&gt; 这里是显示的分类数据，反正这里就是当滑盖用 &lt;/div&gt;&lt;/div&gt; 1234567.more-tags &#123; height: 0; display: flex; flex-wrap: wrap; overflow: hidden; transition: all 0.6s;&#125; 12345678910const tagSelecting = ref&lt;boolean&gt;(false);const moreTagsDom = ref&lt;HTMLElement&gt;() as Ref&lt;HTMLElement&gt;;function slideList() &#123; if (tagSelecting.value) &#123; moreTagsDom.value.style.height = &#x27;0px&#x27;; &#125; else &#123; moreTagsDom.value.style.height = `$&#123;moreTagsDom.value.scrollHeight&#125;px`; &#125; tagSelecting.value = !tagSelecting.value;&#125; 后话自从写了小程序的 uni-app 之后，有点不敢操作 DOM 了，啥都想首先用 vue 式的数据驱动实现，毕竟小程序的 DOM 操纵是个残废，更多的时候完全用不了，只能不用，有种便秘拉不出来的感觉 还是浏览器的前端写着爽，api 又多又全，vue 实现不了的直接干原生 h5","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生h5","slug":"原生h5","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fh5/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.fun/tags/vue/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.fun/tags/TypeScript/"},{"name":"css","slug":"css","permalink":"http://wishao.fun/tags/css/"}]},{"title":"解决github pages部署vue单页面应用url定向错误问题","slug":"解决github-pages部署vue单页面应用url定向错误问题","date":"2024-02-23T13:18:37.000Z","updated":"2024-02-23T14:03:54.532Z","comments":true,"path":"2024/02/23/解决github-pages部署vue单页面应用url定向错误问题/","link":"","permalink":"http://wishao.fun/2024/02/23/%E8%A7%A3%E5%86%B3github-pages%E9%83%A8%E7%BD%B2vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8url%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/","excerpt":"github pages 在遇到根目录之外的 url，会直接去根目录找对应文件，找不到就 404这和期望部署的单页面 app 是不符的，我还是希望能用 vue router 的 history 模式，url 好看的单页面应用所幸 github pages 在找不到会先默认进入 404.html，所以可以通过这个页面来重定向，解决这个问题","text":"github pages 在遇到根目录之外的 url，会直接去根目录找对应文件，找不到就 404这和期望部署的单页面 app 是不符的，我还是希望能用 vue router 的 history 模式，url 好看的单页面应用所幸 github pages 在找不到会先默认进入 404.html，所以可以通过这个页面来重定向，解决这个问题 前言用 vue 写了个静态页面，懒得弄服务器，所以直接部署在 github pages 上用了 Vue Router，是个单页面应用，一般来说应该可以通过 url 直接进入 spa 的某页面比如说 https://sb6657.cn/search?s=ququ 应该直接进搜索页搜索 ququ 但是部署完发现直接白屏啥都没有，查了查原来是 github pages 没有默认处理路由，没有把所有请求都定向到 index.html 导致的它会在遇到非/路由的时候直接去根目录找对应文件，找不到就重定向到 404.html，这个也没有的话就直接白屏了 解决hash 路由两个方案，第一是用 hash 路由，github pages 不会处理 hash 路由，所以能用，vue router 里开启 hash 模式就行了不过 url 里带个#确实不好看也不好用，所以我不想用 在 404.html 中重定向方案二就是利用了找不到相应文件会进入 404.html 的特性，在这里记录输入 url，重定向回主页再操纵就行了。要改的是，加一个 404.html，改一下 App.vue 我用的 vue3 + vite + typescript，顺带解决一下页面部署之后不在根 url 的页面定向问题所以还再加改一个 vite.config.ts 404.html在/public里建一个 404.html，存当前 path 并重定向，如下 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;YOUR TITLE&lt;/title&gt; &lt;script&gt; /** * 应对github page之类的部署单页面应用时，重定向错误问题 * 这种遇到url会直接去根目录找对应文件，如果没有就直接进入404.html * 所以在404.html里暂存当前路径，然后重定向回首页，首页再改url就能实现单页面应用 */ // 如果你的页面访问路径是 www.xxx.com/projectname ,这里就填&#x27;/projectname&#x27; // 如果访问路径直接是 www.xxx.com根目录，就直接填&#x27;/&#x27; // 注意vite.config.ts也要相应更改 const projectName = &#x27;/projectname&#x27;; let relativePath = location.pathname; // 路径以项目名开头时，移除掉。不然会因为vite的处理，重复一次 if (relativePath.startsWith(projectName)) &#123; // 移除基础路径 relativePath = relativePath.substring(projectName.length); &#125; // 添加查询字符串 if (window.location.search) &#123; relativePath += window.location.search; &#125; // 保存最终的路径到sessionStorage，用于SPA中的重定向 sessionStorage.setItem(&#x27;redirect&#x27;, relativePath); // 重定向到基础路径 window.location.href = projectName; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; App.vue改 App.vue，在页面加载之前，获取之前 404.html 里存的路径，在这再改回去 1234567891011import &#123; useRouter &#125; from &#x27;vue-router&#x27;;import &#123; onBeforeMount &#125; from &#x27;vue&#x27;;// 应对github page之类的重定向，实现部署spa能用url查询定向const redirect = sessionStorage.getItem(&#x27;redirect&#x27;);onBeforeMount(async () =&gt; &#123; if (redirect) &#123; console.log(&#x27;重定向到&#x27;, redirect); await useRouter().push(redirect); sessionStorage.removeItem(&#x27;redirect&#x27;); &#125;&#125;); vite.config.ts这里解决一下不是根目录的 url 部署页面的问题如之前的注释，如果页面访问路径是 www.xxx.com/projectname ,这里就填&#39;/projectname/&#39;如果访问路径直接是 www.xxx.com根目录，就直接填&#39;/&#39; 123export default defineConfig(&#123; base: &#x27;/projectname/&#x27;,&#125;); 注：不写 base 属性的话，默认值是&#39;/&#39; 总结利用 404.html 里保存了当前的路径，本地暂存下，传给 Vue，再改 url 就不被 github pages 限制了","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"http://wishao.fun/tags/vue/"},{"name":"vite","slug":"vite","permalink":"http://wishao.fun/tags/vite/"},{"name":"github","slug":"github","permalink":"http://wishao.fun/tags/github/"}]},{"title":"解决滚动穿透问题","slug":"解决滚动穿透问题","date":"2023-12-20T14:51:57.000Z","updated":"2023-12-20T15:22:31.747Z","comments":true,"path":"2023/12/20/解决滚动穿透问题/","link":"","permalink":"http://wishao.fun/2023/12/20/%E8%A7%A3%E5%86%B3%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/","excerpt":"uni-app 编译到支付宝小程序，滚动穿透问题解决通用解决，解决了弹窗和根组件同时可以滚动，但是只想滚动弹窗而不想根组件跟着滚动的情况","text":"uni-app 编译到支付宝小程序，滚动穿透问题解决通用解决，解决了弹窗和根组件同时可以滚动，但是只想滚动弹窗而不想根组件跟着滚动的情况 问题因为在做 uniapp 编译到支付宝小程序，用的人少，网上没查到现成的解决方案现有解决方案多用到浏览器 api，阻止冒泡，支付宝小程序真没有，现有的 api 我试了没用 要解决的问题是，经典滚动穿透问题弹窗和根组件同时可以混动，因为滚动穿透的存在，滚动弹窗下面的根组件一并会被滚动想要实现的是只弹窗滚动，下面的根组件不动。 解决方案思路在弹窗出来后，记录根组件滚动位置，然后给根组件设置成 position:fixed 状态弹窗解除后，从 fixed 状态恢复，并根据记录的滚动位置，回到此前位置 可以说是相当粗暴，啥穿透，啥冒泡，直接不管，看 fixed 划不划的动就完事了所以说也通用，支付宝小程序都能用 示例比如说简单结构如下，root 和 dialog 里面都有大量内容，都可以滚动 123&lt;div class=&quot;root&quot; :style=&quot;rootFixed&quot;&gt; &lt;div class=&quot;dialog&quot;&gt;&lt;/div&gt;&lt;/div&gt; 在 dialog 出来之后，获取 root 当前滚动位置，并且改成 fixed，fixed 的 top 设置成滚动位置 1234567891011121314151617// 记录当前滚动位置let currentScrollTop = 0;// root的styleconst rootFixed = ref(&#x27;&#x27;);function saveCurrentScrollPosition() &#123; // 这是支付宝小程序获取dom的api my.createSelectorQuery() .selectViewport() .scrollOffset((res: any) =&gt; &#123; currentScrollTop = res.scrollTop; console.log(currentScrollTop); // 设置根元素在滑动标题的时候fixed的位置 // 由于这个dom获取api是异步的，直接放回调函数里面赋值了 rootFixed.value = `position: fixed; top: -$&#123;currentScrollTop&#125;px;`; &#125;) .exec(() =&gt; &#123;&#125;);&#125; 最后在弹窗解除后，根据之前记录的位置，把根组件滚动回去 12345678910111213// 恢复滚动位置async function resetScrollPosition() &#123; // 这里这么写是因为my.pageScrollTo操作顺序必须在设置完position: static之后。 // 其实我试了，await sleep(1)之后都能正常，但是直接写就不正常了。。。放promise后算了 await new Promise((r) =&gt; &#123; rootFixed.value = &#x27;position: static&#x27;; r(&#x27;&#x27;); &#125;); my.pageScrollTo(&#123; scrollTop: currentScrollTop, duration: 0, &#125;);&#125; 最后俩垃圾平台，这么经典问题都没现成解决方案哎，要怪只能怪自己一块选俩罕见平台，强强组合了属于是，坑 × 坑","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"小程序","slug":"web前端/小程序","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.fun/tags/vue/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.fun/tags/TypeScript/"},{"name":"uni-app","slug":"uni-app","permalink":"http://wishao.fun/tags/uni-app/"},{"name":"小程序","slug":"小程序","permalink":"http://wishao.fun/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"支付宝小程序","slug":"支付宝小程序","permalink":"http://wishao.fun/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"uni-app 支付宝小程序开发踩坑记录","slug":"uni-app-支付宝小程序开发踩坑记录","date":"2023-11-20T15:44:44.000Z","updated":"2023-12-22T14:22:27.896Z","comments":true,"path":"2023/11/20/uni-app-支付宝小程序开发踩坑记录/","link":"","permalink":"http://wishao.fun/2023/11/20/uni-app-%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"支付宝小程序， ios 上音频播放失败、DOM 魔改、ref 引用、免域名调用失效 等各种各样的坑 我选了两个垃圾平台，自己踩了两倍的坑","text":"支付宝小程序， ios 上音频播放失败、DOM 魔改、ref 引用、免域名调用失效 等各种各样的坑 我选了两个垃圾平台，自己踩了两倍的坑 1、踩坑之 ios 音频播放失效坑比如说一个简单的 uniapp 的音频播放，下面俩函数绑定到对应的播放停止按钮上。代码如下 123456789101112const testaudio = uni.createInnerAudioContext();testaudio.src = &#x27;https://m701.music.126.net/20231121002122/6cab596b822faccb93fdf042dadb9bcc/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/31223625128/85a6/7924/89bd/de76bcf275daa45deba6da310e78c31c.m4a&#x27;;testaudio.onCanplay(() =&gt; &#123; console.log(&#x27;音频1加载完成&#x27;);&#125;);function play1() &#123; testaudio.play();&#125;function stop1() &#123; testaudio.pause();&#125; uniapp 编译到支付宝小程序了，然后我使用真机测试，成功播放。但是诡异的就是我朋友的手机测试失败。 一连试了好几个人，发现是安卓能正常播放，ios 失败，太诡异了。 但是那个加载完成又是实打实的，就是播放出了问题。 支付宝开发者平台文档啊，社区啊看了半天，然后发现一个问同样问题的，时间停止在 23 年 3 月，没人回，没解决。 我服了，这么严重的功能问题，支付宝小程序你那文档怎么写的，ios 放不出来音频啊，近一半的用户啊 解决最后 google 了一晚上，瞎试了好多方法，还去看了微信小程序社区，最后解决了。 ios 有个默认全局静音的策略，支付宝 app 估计是开了，需要给音频设置静音也能播放才行 1testaudio.obeyMuteSwitch = false; 设置完再给朋友手机真机测试，音频放出来了，我也成功因为支付宝平台的垃圾文档浪费了一晚上时间 2、踩坑之音频 audioContext 对象只能同时存在 6 个坑在做无障碍组件，盲人使用，所以需要音频播放 我的解决方案就是先把现成的音频放到 oss 对象储存上，然后获取外链，直接播放 uniapp 里音频播放大概要这么写 1234567let audio = uni.createInnerAudioContext();audio.src = &#x27;xxxx.xxxxx.url&#x27;;// 这个必须写，不然ios放不出声音audio.obeyMuteSwitch = false;audio.onCanplay(() =&gt; &#123; audio.play();&#125;); 本来打算直接给每个组件都这么直接 new 好，然后点击直接调用 audio.play 完事 结果发现放多了音频之后，前面最早弄的就放不出声音来了 解决反复实验发现，支付宝小程序是同时只能存在 6 个 audio 上下文 audioContext 对象，多了的话后面的会覆盖前面的，也就放不出声音来了 所以解决就是随用随 new，放完就释放。大概就是这样 123456789101112131415let audio: UniApp.InnerAudioContext | null;function audioCreatePlay() &#123; audio = uni.createInnerAudioContext(); audio.src = props.audioUrl; // 这个必须写，不然ios放不出声音 audio.obeyMuteSwitch = false; audio.onCanplay(() =&gt; &#123; audio?.play(); &#125;);&#125;// 用audioCreatePlay();// 用完直接释放audio?.destroy();audio = null; 3、踩坑之注意 vue3 单项数据流坑好吧这个其实跟 uniapp 没啥关系，纯纯是我不遵守 vue 规范 我试图直接在父组件用ref()声明完响应变量之后，直接传递引用给子组件，然后子组件拿着变量引用改变此变量，能让父组件的此 ref 变量变化 结果当然是不行 解决这么写没遵守 vue 框架单项数据流的规定，当然不行 就算是 v-moudle 的双向绑定，其实也是封装的传方法和监控，然后子组件调父组件方法完成两边同步 所以说还是应该正常完成子组件传父组件数据的过程，在父组件定义函数操纵自己的变量，然后子组件defineEmits暴露，子组件使用此传参，完成子传父 4、踩坑之支付宝不支持事件委托，因为它魔改了 DOM坑起因是我想实现组件点击计数，点击到 5 次没有交互的位置，就默认做点什么；如果点击的是有交互的地方，就不干什么，不能给每个东西都绑点击函数吧，所以我想到了事件委托，给根组件绑一个函数就完事了 结果发现是，做不到，点击的对象上怎么啥方法都没有，常用的e.target.closest()直接找不到函数 绑定在 dom 上的函数，形参e，然后我打印了一下e，发现确实没法了，他们给 dom 改完了 比如说有个简单的结构如下 1234567&lt;view class=&quot;wai&quot; onTap=&quot;onTapTest&quot; data-wai=&quot;wai&quot; id=&quot;wai&quot;&gt; 456 &lt;view class=&quot;nei&quot; data-nei=&quot;nei&quot; id=&quot;nei&quot;&gt; 123 &lt;view class=&quot;neinei&quot; data-nei=&quot;neinei&quot; id=&quot;neinei&quot;&gt; 000 &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123onTapTest(e)&#123; console.log(e);&#125; 然后打印结果很令人难受，说明这个 dom 里是啥都没有，对比浏览器的 dom 就这么点东西 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//点击最外面的打印&#123; &quot;currentTarget&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;wai&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 94, &quot;tagName&quot;: &quot;view&quot; &#125;, &quot;detail&quot;: &#123; &quot;clientX&quot;: 70, &quot;clientY&quot;: 263, &quot;pageX&quot;: 70, &quot;pageY&quot;: 263 &#125;, &quot;target&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;wai&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 94, &quot;tagName&quot;: &quot;view&quot;, &quot;targetDataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125; &#125;, &quot;timeStamp&quot;: 1700819502522, &quot;type&quot;: &quot;tap&quot;, &quot;mark&quot;: &#123;&#125;&#125;// 点击中间的打印&#123; &quot;currentTarget&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;wai&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 94, &quot;tagName&quot;: &quot;view&quot; &#125;, &quot;detail&quot;: &#123; &quot;clientX&quot;: 80, &quot;clientY&quot;: 156, &quot;pageX&quot;: 80, &quot;pageY&quot;: 156 &#125;, &quot;target&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;nei&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 113, &quot;tagName&quot;: &quot;view&quot;, &quot;targetDataset&quot;: &#123; &quot;nei&quot;: &quot;nei&quot; &#125; &#125;, &quot;timeStamp&quot;: 1700819522863, &quot;type&quot;: &quot;tap&quot;, &quot;mark&quot;: &#123;&#125;&#125;// 点击最中间的打印&#123; &quot;currentTarget&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;wai&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 94, &quot;tagName&quot;: &quot;view&quot; &#125;, &quot;detail&quot;: &#123; &quot;clientX&quot;: 28, &quot;clientY&quot;: 153, &quot;pageX&quot;: 28, &quot;pageY&quot;: 153 &#125;, &quot;target&quot;: &#123; &quot;dataset&quot;: &#123; &quot;wai&quot;: &quot;wai&quot; &#125;, &quot;id&quot;: &quot;neinei&quot;, &quot;offsetLeft&quot;: 0, &quot;offsetTop&quot;: 132, &quot;tagName&quot;: &quot;view&quot;, &quot;targetDataset&quot;: &#123; &quot;nei&quot;: &quot;neinei&quot; &#125; &#125;, &quot;timeStamp&quot;: 1700819539734, &quot;type&quot;: &quot;tap&quot;, &quot;mark&quot;: &#123;&#125;&#125; 解决根据打印出来的东西来看，冒泡还在，currentTarget始终指向绑定事件的最外层元素，target指向实际被点击的元素，且携带着各自的dataset信息。 但是确实鼠标点击事件的 target 全改了，各种方法没有了，没法拦截点击到最外层，事件委托算基本用不了了 当时我要做的是组件点击计数，点击到 5 次没有交互的位置，就默认做点什么；如果点击的是有交互的地方，就不干什么 笨方法，写个全局变量，直接给所有交互组件都绑个函数，点击变量置 0；给最根组件也绑个函数，点击变++。然后变量监听，到了 5 就触发某函数 非常笨的方法了，反正是实现了 5、踩坑之单页面组件渲染坑uni 路由跳转的话，其实是切换了页面。我想不出现那个页面转换的动画，想让它感觉是直接刷新的 但是 uniapp 没 vue 的 router 路由管理，所以我只能用手动用条件渲染切换组件的方式进行 1&lt;component :is=&quot;...&quot;&gt;&lt;/component&gt; 然后发现 is 条件渲染也不支持。。。这就是 uniapp 我想浏览器真 vue 的 router 了 😭😭😭 想怎么弄子路由就怎么弄子路由 😭😭😭 解决组件用v-if得了。。。 123&lt;component1 v-if=&quot;condition&quot;&gt;&lt;/component1&gt;&lt;component2 v-if=&quot;condition&quot;&gt;&lt;/component2&gt;&lt;component3 v-if=&quot;condition&quot;&gt;&lt;/component3&gt; 23&#x2F;12&#x2F;7 补充今天看同伴代码，看出来别的解决办法了。uniapp 里有 TabBar 组件的存在，app 里挺常用的东西，本来是用来做底部栏，单个页面内路由跳转，不刷新。 所以给了 uni.switchTab() 方法，按规定在 page.json 里配置好底部栏对应页面，调用就能直接在单个页面里切换，不刷新的效果。 但这是 uniapp 自带的默认底部栏，写配置就有的那个，太丑了，没法用，所以干脆直接隐藏掉，只用给的方法切换页面。小程序没给自定义底部栏的方法，只能自己搓，分别在各页面底部用，然后 pinia 分享状态记住当前选择 6、踩坑之支付宝小程序插件，uniapp 里没法给组件导入，只能给页面引入坑结合上一条，我想在组件里引入支付宝小程序的插件，实现页面里面的调用，无缝刷新 但是发现支付宝小程序原生插件引入不了组件里 解决没法了，不给组件引入了，直接给页面引入 本来只管路由组件切换的页面，这下写了一堆东西，调用插件的逻辑全写里面了，真没法 7、踩坑之 callContainer 免域名调用实现长轮询坑支付宝小程序，后端部署在支付宝小程序云托管上的话，关联了对应小程序就有免域名调用可以用。 官方文档在此callContainer（其实官方文档写的一坨史，有时间能单开一篇专门说踩过的坑。而且完全照搬的微信小程序云，支付宝那找不到解决方案的，直接去看微信的社区，简直 1:1 复刻，那边帮你把坑踩好了） 现在要实现简单的后端主动推送。因为业务不复杂，所以不想用 websocket 了，直接上长轮询完事 但是诡异的事就是，后端自测 60s 长轮询，没问题，我自己用小程序云的公网测试网址测，也没问题，但是小程序上真用免域名调用就 6s 超时，超时直接 throw 出调用失败 我都怀疑官网写的默认 timeout 参数是 60000 是少写了个零 解决小程序开发工具的问题。反复在调用前后打印时间戳验证时间，发现免域名调用自定义的 6s 以内的超时时间，都能正确实现，写多少就是多少，throw 出来的是超时错误。但是写超过 6s 的超时时间，就直接 6s 给你 throw 出调用失败，看来最大上限是 6s 解决方法是上真机调试，纯纯 ide 的问题。ide 设置的 6s 上限，手机真测就是 60s 的上限，60s 内的自定义超时时间都有效，超过 60s 才上限显示是 60s 调用失败 补充其实想过备选方案是直接在小程序上跑测试域名调试，反正最后调的小程序云，又不是不能用。 而且这么调还直接走的my.request，这个接口有中断方法，太棒了。（免域名调用没提供调用中断，太牛逼了这个，这都没有，长轮询只能轮到后端给结果或者超时） IDE 上一切安好，有中断就不用处理很多由于没有中断方法引出的问题。 但是实际上就是不能用。。。看了文档说 为什么 my.request 接口设置超时时间后依旧超时？timeout 设置超时时间，Android 会不生效（默认是 30 秒，不同的网络状态也不一样，wifi 15 秒， 4G 20 秒）后续会更新统一，具体更新请关注小程序 更新日志。 确实没法了，用不了算了，凑合用免域名调用，超时至少都有 55s 打底 8、踩坑之隐藏支付宝小程序的默认 tabbar坑支付宝小程序的默认 tabbar 很丑，并且自定义只能改颜色和图标，产品画的那复杂的底部栏实现不了，所以就用自定义方案吧。 自定义更是简单粗暴，直接uni.hideTabBar()隐藏原底部栏，然后自己搓一个普通组件当底部栏，在各个分页面都创建一个，状态用 pinia 共享直接当替身使者，原底部栏只调用它的uni.switchTab()。 ide 上跑着挺不错，真机调试也没事，但是一上线就直接出现了uni.hideTabBar()调用失败，一直报此页面不在 tabbar 上，就造成页面卡死，下面的也点不动了 解决进入含在 tabbar 上的页面别用普通的uni.navigateTo()或者uni.redirectTo()，直接用uni.switchTab()进入。 因为普通方法进入可能调uni.hideTabBar()的时机底部栏还没加载，就出错了 但是用uni.switchTab()处必然加载好了的，就不会有这个错误","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"小程序","slug":"web前端/小程序","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.fun/tags/vue/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.fun/tags/TypeScript/"},{"name":"uni-app","slug":"uni-app","permalink":"http://wishao.fun/tags/uni-app/"},{"name":"小程序","slug":"小程序","permalink":"http://wishao.fun/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"支付宝小程序","slug":"支付宝小程序","permalink":"http://wishao.fun/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"彻底关闭Windows Defender","slug":"彻底关闭windows10-Defender","date":"2023-08-03T03:43:37.000Z","updated":"2024-02-23T14:13:19.228Z","comments":true,"path":"2023/08/03/彻底关闭windows10-Defender/","link":"","permalink":"http://wishao.fun/2023/08/03/%E5%BD%BB%E5%BA%95%E5%85%B3%E9%97%ADwindows10-Defender/","excerpt":"又一次被Windows Defender气昏，图吧工具箱前脚刚解压完就无声给我删了，有的学习版游戏更是安装完就把执行程序无声干掉了。受不了了，Defender和我必须死一个 目前23年8月3日，Windows10 21H2 19044.3086亲测有效","text":"又一次被Windows Defender气昏，图吧工具箱前脚刚解压完就无声给我删了，有的学习版游戏更是安装完就把执行程序无声干掉了。受不了了，Defender和我必须死一个 目前23年8月3日，Windows10 21H2 19044.3086亲测有效 起因在不知道多少次被Windows Defender自动无声误删之后，终于受不了了。 但是在设置里手动关闭的话，重启电脑它会自动再次开启，网上找到的策略组里关闭方法都不管用了，重启电脑都会再打开，微软为了不让我们把它关了真是处心积虑。 幸亏那个关闭小工具还是有用的，网上搜的各种关闭方法鱼龙混杂，索性自己记录下 步骤1. 首先手动关闭windows Defender防病毒打开设置–&gt;更新和安全–&gt;左侧边栏Windows安全中心–&gt;病毒和威胁防护–&gt;”病毒和威胁防护”设置的管理设置 里面有个实施保护，给他关了 这么做只能临时关，重启电脑就又回来了。不过无所谓，临时关是为了用后面的工具，微软给那个工具重点标记了，不关的话一检测到就给你删了 2. 下载工具蓝奏云 密码:c9xo 下载完解压，解压密码2222 3. 使用双击.exe打开，这是有大神汉化了的，点停用就行了 碎碎念其实可以给误删东西加白名单，就不会删了。自己没点判断力的还是建议别给电脑裸奔，有这么个防护的至少有点用 但是我还是要说了，妈的微软为啥不能给个关这种东西的自由，我就是不想用，必须给他关了","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"http://wishao.fun/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"Windows调教","slug":"瞎折腾/Windows调教","permalink":"http://wishao.fun/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/Windows%E8%B0%83%E6%95%99/"}],"tags":[{"name":"Windows10","slug":"Windows10","permalink":"http://wishao.fun/tags/Windows10/"},{"name":"Windows11","slug":"Windows11","permalink":"http://wishao.fun/tags/Windows11/"},{"name":"Defender","slug":"Defender","permalink":"http://wishao.fun/tags/Defender/"},{"name":"关闭","slug":"关闭","permalink":"http://wishao.fun/tags/%E5%85%B3%E9%97%AD/"},{"name":"小软件","slug":"小软件","permalink":"http://wishao.fun/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"}]},{"title":"初识canvas","slug":"初识canvas","date":"2023-07-21T11:44:02.000Z","updated":"2024-02-29T06:41:08.518Z","comments":true,"path":"2023/07/21/初识canvas/","link":"","permalink":"http://wishao.fun/2023/07/21/%E5%88%9D%E8%AF%86canvas/","excerpt":"为了还原小时候玩过的一个 flash 游戏，决定学点 html5 游戏制作。找了个外网教程，先从 canvas 元素开始","text":"为了还原小时候玩过的一个 flash 游戏，决定学点 html5 游戏制作。找了个外网教程，先从 canvas 元素开始 教程原地址JavaScript Game Development Course for Beginners - YouTube canvas1. 从精灵图动画开始首先在 html 里引入 canvas 标签。然后在 js 中获取其 DOM 然后获取 canvas 上的所有方法。 1const ctx = canvas.getContext(&#x27;2d&#x27;); 这里的参数代表 canvas 的属性，2d 是 2d 画布。还有别的，可以做 3d 的东西 下面这么写可以清除画布内容，前面两个参数是要清除的左上角起始点，后面是宽高，表示清除一个矩形 1ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 创建一个存精灵图的对象 1const playerImage = new Image(); 图片的传法，第一个是图片，2 3 是图片起始点（左上角），4 5 是图片拉伸大小 12345ctx.drawImage(playerImage, 0, 0, 6000, 6000);// 还有九个参数的版本，sx sy是图片剪裁起始点，sw sh是剪裁长宽// dx dy是图片放置位置起始点，dw dh是图片放置长宽ctx.drawImage(playerImage, sx, sy, sw, sh, dx, dy, dw, dh); 创建一个帧，使用(其中 animate 传一个函数，可以放包含上面东西的，操纵 canvas) 1requestAnimationFrame(animate); 我们可以在 animate 里使用此函数调用 animate 函数自己，就能实现一直创建帧。 在控制 canvas 的函数的参数里使用变量，并且让他们变化，就能实现基础的动画","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"html5游戏","slug":"web前端/html5游戏","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/html5%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"原生h5","slug":"原生h5","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fh5/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"自学","slug":"自学","permalink":"http://wishao.fun/tags/%E8%87%AA%E5%AD%A6/"},{"name":"canvas","slug":"canvas","permalink":"http://wishao.fun/tags/canvas/"},{"name":"游戏","slug":"游戏","permalink":"http://wishao.fun/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"TypeScript入门","slug":"TypeScript入门","date":"2023-07-15T12:08:27.000Z","updated":"2024-02-29T05:04:02.940Z","comments":true,"path":"2023/07/15/TypeScript入门/","link":"","permalink":"http://wishao.fun/2023/07/15/TypeScript%E5%85%A5%E9%97%A8/","excerpt":"TypeScript 基础再次学习","text":"TypeScript 基础再次学习 TypeScript 基础知识1, 安装使用全局安装 1npm i -g TypeScript 初始化文件夹配置文件 1tsc --init 一般使用，直接输入tsc，就自动把 ts 编译成 js 为了方便，可以监听变化，保存就自动编译 1tsc --watch 2. 基础类型TypeScript 提供了 JavaScript 中所有的基础数据类型，如： boolean number string array tuple enum any void null and undefined never ts 允许我们显示标注类型，或者不标也行，可以隐式推断 1234567891011121314151617181920212223242526272829let isDone: boolean = false;let decimal: number = 6;let color: string = &#x27;blue&#x27;;let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3]; // 用Array对象定义数组let x: [string, number]; // 这是元组x = [&#x27;hello&#x27;, 10];enum Color &#123; Red, Green, Blue,&#125;let c: Color = Color.Green;let notSure: any = 4;notSure = &#x27;maybe a string instead&#x27;;notSure = false;function warnUser(): void &#123; console.log(&#x27;This is my warning message&#x27;);&#125;let unusable: void = undefined;let u: undefined = undefined;let n: null = null; 3. 联合类型TypeScript 的一大特性是能够明确指定一个值可能的类型范围。 1234let value: number | string;value = &#x27;hello&#x27;; // Okvalue = 100; // Okvalue = true; // Error: boolean is not assignable to type &#x27;string | number&#x27; 4. 类型断言类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。主要是因为 ts 的类型检查只能在编译时进行，编译后会抹去类型，变成普通的 js 代码 123let someValue: any = &#x27;this is a string&#x27;;let strLength: number = (&lt;string&gt;someValue).length; // 前置尖括号断言let strLength: number = (someValue as string).length; // as断言，两种都可以 5. 元组和枚举元组类型允许表现一个已知元素数量和类型的数组，各元素的类型不必相同。 1234let tupleType: [string, number];tupleType = [&#x27;hello&#x27;, 10];console.log(tupleType[0].substring(1)); // OKconsole.log(tupleType[1].substring(1)); // Error 枚举是一种特殊的类型，它可以包含一组命名的常量。枚举可以是数字枚举，字符串枚举，异构枚举。 12345678910111213enum Color &#123; Red, Green, Blue,&#125; // numeric enumlet c: Color = Color.Green;enum Direction &#123; Up = &#x27;UP&#x27;, Down = &#x27;DOWN&#x27;, Left = &#x27;LEFT&#x27;, Right = &#x27;RIGHT&#x27;,&#125; // string enum 6. 接口接口在 TypeScript 中是一个重要的概念，它是对行为的抽象，也是鸭子类型的一种表现。 鸭子类型 - 维基百科 12345678910interface LabelledValue &#123; label: string;&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123; size: 10, label: &#x27;Size 10 Object&#x27; &#125;;printLabel(myObj); （简单来说就是，如果你定义了一个接口的结构，然后造了个对象有这个接口一模一样的属性，就算是造这个对象的时候没直接用 implement，TypeScript 也会认为这个对象是这个接口的实现，可以传入某个接受这个接口类型的函数当参数，不会报错） 7. 泛型泛型就是解决类、接口、方法的复用性，以及对不特定数据类型的支持。 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let output = identity&lt;string&gt;(&#x27;myString&#x27;); // type of output will be &#x27;string&#x27;s 8. 装饰器与反射元数据8.1 装饰器装饰器，顾名思义，可以添加一些附加功能在代码中。在 TypeScript 中，装饰器提供了一种方法，能在运行时修改类的行为或对类进行额外的处理。它们可以应用在类，方法，属性或者参数等多个地方。这是一个很强大的功能，允许对类的行为进行扩展，而无需改变类的定义。 装饰器有四种类型： 类装饰器 属性装饰器 方法装饰器 参数装饰器 12345678910111213141516// 类装饰器function sealed(constructor: Function) &#123; Object.seal(constructor); Object.seal(constructor.prototype);&#125;@sealedclass Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return &#x27;Hello, &#x27; + this.greeting; &#125;&#125; 在这个例子中，@sealed装饰器会在运行时应用到Greeter类上，导致无法向Greeter类添加新的属性，并且已有的属性无法删除或配置。 8.2 反射元数据反射元数据是一种在设计阶段添加和读取元数据的方式。反射 API 包含很多功能，如查询类，接口，参数和返回类型等的设计类型。这为库作者提供了一种检查类结构的强大工具。 在 TypeScript 中使用反射元数据，需要使用reflect-metadata库，并在 tsconfig.json 文件中开启emitDecoratorMetadata选项。 这是一个基础的反射元数据使用例子： 1234567891011121314151617181920import &#x27;reflect-metadata&#x27;;class MyClass &#123; @validate public someMethod(someArg: any) &#123; // Do something &#125;&#125;function validate(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;any&gt;) &#123; let originalMethod = descriptor.value; descriptor.value = function (...args: any[]) &#123; let metadataValue = Reflect.getMetadata(&#x27;design:paramtypes&#x27;, target, propertyKey); if (metadataValue !== someArg) &#123; throw new Error(`Validation failed on argument $&#123;someArg&#125;`); &#125; return originalMethod.apply(this, args); &#125;; return descriptor;&#125; 在这个例子中，validate装饰器使用反射 API 来获取someMethod方法参数的设计类型，并检查是否和方法被调用时传入的参数类型一致。如果不一致，就抛出一个错误。 练习1. 封装 fetch，实现简单 axios 功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// 4种请求方法type Method = &#x27;GET&#x27; | &#x27;POST&#x27; | &#x27;PUT&#x27; | &#x27;DELETE&#x27;;// 请求配置interface RequestConfig &#123; url: string; method?: Method; body?: Object; headers?: Record&lt;string, string&gt;;&#125;// 类似axios的返回值设置interface AxiosResponse&lt;T = any&gt; &#123; data: T; status: number; statusText: string; headers: Record&lt;string, string&gt;; config: RequestConfig; // 去看了看axios文档，用fetch的话，搞不到axios底层XHR信息，空着算了 request: &#123;&#125;;&#125;class MyAxios &#123; // 添加请求和响应拦截器数组 requestInterceptors: Array&lt;(config: RequestConfig) =&gt; RequestConfig&gt; = []; responseInterceptors: Array&lt;(response: AxiosResponse&lt;any&gt;) =&gt; AxiosResponse&lt;any&gt;&gt; = []; // 在发送请求前可以添加请求拦截器 useRequestInterceptor(interceptor: (config: RequestConfig) =&gt; RequestConfig): void &#123; this.requestInterceptors.push(interceptor); &#125; // 在收到响应后可以添加响应拦截器 useResponseInterceptor(interceptor: (response: AxiosResponse&lt;any&gt;) =&gt; AxiosResponse&lt;any&gt;): void &#123; this.responseInterceptors.push(interceptor); &#125; // fetch请求调用 private async request&lt;T = any&gt;(config: RequestConfig, method: Method): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; // 请求拦截器 this.requestInterceptors.forEach((interceptor) =&gt; &#123; config = interceptor(config); &#125;); const res: Response = await fetch(config.url, &#123; method, body: config.body ? JSON.stringify(config.body) : undefined, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, ...config.headers, &#125;, &#125;); // 处理fetch的返回值让它更像axios的返回值 if (!res.ok) &#123; throw new Error(`$&#123;res.status&#125; $&#123;res.statusText&#125;`); &#125; const data: T = await res.json(); // status和statusText一样，就不用单独处理，后面直接赋值 const headers: Record&lt;string, string&gt; = &#123;&#125;; res.headers.forEach((value: string, key: string) =&gt; &#123; headers[key] = value; &#125;); let axiosResponse: AxiosResponse&lt;T&gt; = &#123; data, status: res.status, statusText: res.statusText, headers, config, // 只能空着了 request: &#123;&#125;, &#125;; // 响应拦截器 this.responseInterceptors.forEach((interceptor) =&gt; &#123; axiosResponse = interceptor(axiosResponse); &#125;); return axiosResponse; &#125; // get请求，由于可以传config或者直接传url，所以重载了一下 async get&lt;T = any&gt;(url: string): Promise&lt;AxiosResponse&lt;T&gt;&gt;; async get&lt;T = any&gt;(config: RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt;; async get&lt;T = any&gt;(url_or_config: string | RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; let config: RequestConfig; if (typeof url_or_config === &#x27;string&#x27;) &#123; config = &#123; url: url_or_config &#125;; &#125; else &#123; config = url_or_config; &#125; return await this.request&lt;T&gt;(config, &#x27;GET&#x27;); &#125; // post请求 async post&lt;T = any&gt;(config: RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; return await this.request&lt;T&gt;(config, &#x27;POST&#x27;); &#125; // put请求 async put&lt;T = any&gt;(config: RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; return await this.request&lt;T&gt;(config, &#x27;PUT&#x27;); &#125; // delete请求 async delete&lt;T = any&gt;(config: RequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; &#123; return await this.request&lt;T&gt;(config, &#x27;DELETE&#x27;); &#125;&#125;const myAxios: MyAxios = new MyAxios();// 测试get// 添加请求拦截器，添加统一的请求头myAxios.useRequestInterceptor((config: RequestConfig) =&gt; &#123; config.headers = &#123; ...config.headers, &#x27;X-My-Custom-Header&#x27;: &#x27;CustomHeaderValue&#x27;, &#125;; return config;&#125;);// 添加响应拦截器，对响应数据进行一些处理myAxios.useResponseInterceptor((response: AxiosResponse&lt;any&gt;) =&gt; &#123; // 对响应数据进行处理，这里只是简单的加了一个字段 response.data = &#123; ...response.data, fromInterceptor: &#x27;来自响应拦截器，这是ツユ的歌曲列表:&#x27;, &#125;; return response;&#125;);// 发送请求，查看拦截器是否生效myAxios.get(&#x27;http://162.14.111.196:4000/artist/songs?id=34505358&#x27;).then((res: AxiosResponse) =&gt; &#123; console.log(&#x27;测试get\\n&#x27;); console.log(res); console.log(res.data.fromInterceptor + &#x27;\\n&#x27;); res.data.songs.forEach((song: any) =&gt; &#123; console.log(song.al.name); if (song.tns) &#123; console.log(song.tns[0]); &#125; console.log(); &#125;);&#125;); 2. 类型体操之 DeepReadonly123456789101112131415161718type X = &#123; x: &#123; a: 1; b: &#x27;hi&#x27;; c: &#123; d: true; e: &#x27;false&#x27;; f: 3; &#125;; &#125;; y: &#x27;hey&#x27;;&#125;;type DeepReadonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] extends object ? DeepReadonly&lt;T[P]&gt; : T[P];&#125;;type Todo = DeepReadonly&lt;X&gt;;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"TypeScript学习","slug":"web前端/TypeScript学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/TypeScript%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假集训","slug":"暑假集训","permalink":"http://wishao.fun/tags/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.fun/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.fun/tags/TypeScript/"}]},{"title":"react入门","slug":"react入门","date":"2023-07-14T13:45:29.000Z","updated":"2024-02-29T05:04:09.267Z","comments":true,"path":"2023/07/14/react入门/","link":"","permalink":"http://wishao.fun/2023/07/14/react%E5%85%A5%E9%97%A8/","excerpt":"进行一个 react 的速通","text":"进行一个 react 的速通 1. 建立项目建议用 vite 搭建，很快 1npm create vite@latest 然后选 react 模板 2. JSXJSX (JavaScipt XML) 就是 react 中的 HTML，通过 js 的自身可编程能力来创建 HTML 结构 将命令式写法简化为声明式写法 3. 函数式组件新 react 基本不用 class 组件了，全用函数式组件。它们的各种东西也受影响，想做函数式编程 函数式组件例如: 1234567891011function Hello() &#123; return &lt;div style=&#123;&#123; color: &#x27;red&#x27; &#125;&#125;&gt;Hello World!&lt;/div&gt;;&#125;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;Hello&gt;&lt;/Hello&gt; &lt;/div&gt; );&#125; 注意函数名首字母大写，return 的也只能有一个根组件 4. 组件通信父传子父组件提供需要传递的数据 state给子组件标签添加属性值为 state 中的数据函数式子组件直接通过参数获取 props 对象，接收父组件中传过来的值 子传父本质是子组件调用父组件传递的函数，并将想要传递的数据当成函数的实参 5. hooks为了拥抱函数式编程所做的东西。因为真正的函数式编程不允许函数有副作用，但是这是前端，组件不可避免的需要有储存信息，交互其他东西的功能，就引入了 hooks 来做这些事，假装自己还是函数式编程。 Hook 就是 Javascript 函数，但是只能在函数外层调用 Hook，不要在循环、条件判断或者子函数中调用；只能在 React 的函数组件和自定义 Hook 中调用 Hook。不要在其他 JavaScript 函数中调用 useStateuseState 是一个函数，它接受初始状态作为参数，并返回一个包含两个元素的数组：当前状态和一个用于更新状态的函数。比如： 1const [count, setCount] = useState(0); 在这个例子中，count 是当前的状态（初始值为 0），而 setCount 是一个函数，可以用于更新 count 的值。 useEffectuseEffect 允许在函数组件中执行副作用操作。它接受一个函数（通常称之为“effect”）作为参数。可以在 effect 中执行任何副作用操作，例如数据获取、订阅或手动修改 DOM。useEffect 还可以返回一个函数，该函数将在组件卸载前或更新前执行，可以在这个函数中执行任何清理操作。 1234567useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; return () =&gt; &#123; // cleanup logic goes here &#125;;&#125;, [count]); // 仅在 count 更改时更新 useRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 123const inputRef = useRef(null);// you can access its current value like thisconsole.log(inputRef.current); useContextuseContext 接受一个上下文对象（React.createContext 的返回值）并返回该上下文的当前值。当前的上下文值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 123const ThemeContext = React.createContext(&#x27;light&#x27;);const theme = useContext(ThemeContext);console.log(theme); // &quot;light&quot; useReduceruseReducer 是一个替代 useState 的 Hook，它接受一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的状态以及与其配套的 dispatch 方法。 1234567891011121314151617181920212223const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123; count: state.count + 1 &#125;; case &#x27;decrement&#x27;: return &#123; count: state.count - 1 &#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"react学习","slug":"web前端/react学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/react%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假集训","slug":"暑假集训","permalink":"http://wishao.fun/tags/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"自学","slug":"自学","permalink":"http://wishao.fun/tags/%E8%87%AA%E5%AD%A6/"},{"name":"react","slug":"react","permalink":"http://wishao.fun/tags/react/"}]},{"title":"Vue响应式原理","slug":"Vue响应式原理","date":"2023-07-13T07:55:35.000Z","updated":"2024-03-19T10:26:08.109Z","comments":true,"path":"2023/07/13/Vue响应式原理/","link":"","permalink":"http://wishao.fun/2023/07/13/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"为了深入理解 vue 的响应式数据，手写还原 ref、reactive、computed","text":"为了深入理解 vue 的响应式数据，手写还原 ref、reactive、computed 前置知识见 JavaScript 现代教程。基于映射，集合与代理完成响应式数据 Map 和 SetProxy 和 Reflectreactive比较复杂，考虑到会有多个响应式对象，每个对象有多个属性，每个属性有多个影响它的函数，所以用三级结构储存最顶部是是个 WeakMap，存储的是那多个响应式对象，每个对象对应一个 Map，存储的是这个对象的多个属性，每个属性对应一个 Set，存储的是影响这个属性的多个函数然后用 proxy 代理，当读取属性时，触发收集依赖，当设置属性时，触发更新。同时由于没有给影响函数命名，所以设置了一个数组当堆栈储存影响函数，应对同时注册多个函数的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 使用 WeakMap 来存储每个对象的依赖关系const targetMap = new WeakMap();// 当前活动的 effect 函数，默认为 nulllet activeEffect = null;// 用一个数组来实现堆栈，存储所有的 effect 函数let activeEffectStack = [];// effect 函数用于设置当前的活动 effectfunction effect(eff) &#123; try &#123; // 把 eff 函数添加到堆栈中，并设为当前活动的 effect activeEffectStack.push(eff); activeEffect = eff; // 立即执行 eff 函数 eff(); &#125; finally &#123; // 执行完 eff 函数后，把它从堆栈中移除，并恢复之前的活动 effect activeEffectStack.pop(); activeEffect = activeEffectStack[activeEffectStack.length - 1]; &#125;&#125;// track 函数用于设置对象属性的依赖function track(target, key) &#123; // 只有当有活动的 effect 时才进行依赖收集 if (activeEffect) &#123; let depsMap = targetMap.get(target); if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if (!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(activeEffect); &#125;&#125;// trigger 函数用于触发对象属性的更新function trigger(target, key) &#123; const depsMap = targetMap.get(target); if (depsMap) &#123; const dep = depsMap.get(key); if (dep) &#123; dep.forEach((eff) =&gt; &#123; eff(); &#125;); &#125; &#125;&#125;// reactive 函数用于创建一个响应式的对象，使用了proxy拦截修改或者读取function reactive(target) &#123; return new Proxy(target, &#123; get(target, key, receiver) &#123; // 使用Reflect，直接能调用这些隐藏的底层方法 const result = Reflect.get(target, key, receiver); track(target, key); return result; &#125;, set(target, key, value, receiver) &#123; const oldValue = Reflect.get(target, key, receiver); const result = Reflect.set(target, key, value, receiver); if (oldValue !== value) &#123; trigger(target, key); &#125; return result; &#125;, &#125;);&#125;// 测试代码let product = reactive(&#123; price: 10, quantity: 2 &#125;);let total = 0, salePrice = 0;effect(() =&gt; &#123; total = product.price * product.quantity;&#125;);effect(() =&gt; &#123; salePrice = product.price * 0.9;&#125;);console.log(total, salePrice); // 20 9product.quantity = 5;console.log(total, salePrice); // 50 9product.price = 20;console.log(total, salePrice); // 100 18 捋顺一下此测试代码的执行过程: 创建响应式对象 首先调用reactive传入我们要变成响应式的对象&#123; price: 10, quantity: 2 &#125;，返回一个经过 proxy 代理的对象，命名为product。 设置第一个影响函数 然后使用effect设置影响函数。effect内部会先给传入的影响函数加入堆栈顶，然后执行一次此函数。执行过程中涉及到了product.price * product.quantity，也就是说读取了product，被 proxy 的 get 拦截到。 proxy 的 get 里使用product和它的值.price调用track，在三级储存结构里逐层注册。最后一层 Set 里注册了堆栈顶的那个才传入的影响函数。同时product.quantity也干了一样的事，不过第一层已经有product了，就在product下第二层注册.quantity，也给它加上了那个影响函数。 结束track，使用 Reflect 的 get 再获取一下product.price，返回。 终于结束了调用这次影响函数，这个影响函数也从堆栈顶弹出。 设置第二个影响函数 然后就是注册了第二个影响函数，也做了类似的一套流程，为price多加了个影响函数。 打印初始值 console.log部分，没啥说的，就是打印俩普通值。它们在注册影响函数的时候，因为那次立即执行，获得了数据。 修改 product.quantity 随后是改变product.quantity的值为 5，被 proxy 的 set 拦截到，确认是更改，使用product和.quantity属性调用了更新器trigger。更新器在三级储存结构里找到这个对象和属性，执行一次.quantity所有注册在 Set 里的影响函数。它只注册了第一个影响函数，就执行，重新计算了total的值。打印，发现了total的变化。 修改 product.price 下面改变price同理，proxy 的 set 拦截，调用触发器，执行price下面的俩影响函数，再次打印输出就看见俩个值都变了。 ref因为每次的更新都需要调用.value，所以 ref 比较简单，只需要用 value 的 get set 就能实现自动更新，不需要像实现 reactive 那样使用 proxy 代理来拦截读取或写入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 使用 WeakMap 来存储每个对象的依赖关系const targetMap = new WeakMap();// 当前活动的 effect 函数，默认为 nulllet activeEffect = null;// 用一个数组来实现堆栈，存储所有的 effect 函数let activeEffectStack = [];// effect 函数用于设置当前的活动 effectfunction effect(eff) &#123; try &#123; // 把 eff 函数添加到堆栈中，并设为当前活动的 effect activeEffectStack.push(eff); activeEffect = eff; // 立即执行 eff 函数 eff(); &#125; finally &#123; // 执行完 eff 函数后，把它从堆栈中移除，并恢复之前的活动 effect activeEffectStack.pop(); activeEffect = activeEffectStack[activeEffectStack.length - 1]; &#125;&#125;// track 函数用于设置对象属性的依赖function track(target, key) &#123; // 只有当有活动的 effect 时才进行依赖收集 if (activeEffect) &#123; let depsMap = targetMap.get(target); if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if (!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(activeEffect); &#125;&#125;// trigger 函数用于触发对象属性的更新function trigger(target, key) &#123; const depsMap = targetMap.get(target); if (depsMap) &#123; const dep = depsMap.get(key); if (dep) &#123; dep.forEach((effect) =&gt; &#123; effect(); &#125;); &#125; &#125;&#125;// ref 函数用于创建一个可响应的对象function ref(raw) &#123; const r = &#123; _is_ref: true, // 添加一个标记，表示这是一个 ref 对象 _value: raw, // 存储原始值 // 当访问 value 属性时，进行依赖收集 get value() &#123; track(r, &#x27;value&#x27;); return this._value; &#125;, // 当设置 value 属性时，触发更新 set value(newVal) &#123; this._value = newVal; trigger(r, &#x27;value&#x27;); &#125;, &#125;; return r;&#125;const count = ref(0);console.log(count.value); // 0// 创建一个 effect，监听 count 的变化effect(() =&gt; &#123; console.log(`count的值是: $&#123;count.value&#125;`);&#125;);// 改变 count.value，触发更新count.value++; computed调用了之前完成的 ref 完成 12345678910111213141516171819202122// 前面就是上面ref和reactive的代码// computed 函数用于创建一个计算属性function computed(getter) &#123; const result = ref(); effect(() =&gt; (result.value = getter())); return result;&#125;let product = reactive(&#123; price: 10, quantity: 2 &#125;);let salePrice = computed(() =&gt; &#123; return product.price * 0.9;&#125;);let total = computed(() =&gt; &#123; return salePrice.value * product.quantity;&#125;);console.log(total.value, salePrice.value); // 18, 9product.quantity = 5;console.log(total.value, salePrice.value); // 45, 9product.price = 20;console.log(total.value, salePrice.value); // 90, 18 computed 函数结合了这两个函数的功能。首先用 ref 创建了一个响应式数据 result，然后用 effect 创建了一个副作用，这个副作用的作用就是计算传入的 getter 函数，并把结果赋值给 result.value。所以当 getter 函数内部使用的任何响应式数据发生变化时，getter 函数就会被重新计算，result.value 也会被更新。最后，computed 函数返回这个 result，也是个响应式的（ref）。外部代码可以通过读取 result.value 来获取计算的结果，也可以通过观察 result.value 的变化来响应这个计算结果的变化。 感悟手写实现确实能深入理解代码。。。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假集训","slug":"暑假集训","permalink":"http://wishao.fun/tags/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.fun/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"},{"name":"vue","slug":"vue","permalink":"http://wishao.fun/tags/vue/"}]},{"title":"前端零碎拾遗","slug":"前端零碎拾遗","date":"2023-07-12T13:45:00.000Z","updated":"2024-02-29T06:40:51.547Z","comments":true,"path":"2023/07/12/前端零碎拾遗/","link":"","permalink":"http://wishao.fun/2023/07/12/%E5%89%8D%E7%AB%AF%E9%9B%B6%E7%A2%8E%E6%8B%BE%E9%81%97/","excerpt":"汇总下写着写着突然又想起来或者才听说的东西","text":"汇总下写着写着突然又想起来或者才听说的东西 html经常忘的标签 &lt;hr/&gt;横线 emmet 语法 TAB 键+标签名快速生成标签 div*4 生成 4 个 div ul&gt;li 快速生成包含关系 div+p 快速生成兄弟关系 span.nar 快速标签内类名 .aad$*5快速依次生成5个aad类名(无$就生一样的) div{东西} css去下划线text-decoration: none; 去输入框点击时边框outline:none; :root这个伪类表示 html 标签，而且比他等级更高，是 dom 树里根中之根，可以存点变量啥的 var()函数可以调用存在父节点里的变量 主义变量命名要以两个横杠–开头 居中更多技巧1. 定位时用负边距居中这个需要已知元素大小 比如说定位是left: 50%，元素100px宽那可以设置margin-left: -50px实现居中 2. 定位和 transform 居中这个不需要元素大小，可以对动态的元素设置 设置父元素position: relative，随后对子元素设置 1234position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%); 3. 定位和 flex 同时使用，让多元素重叠居中这个可能不常用，但确实来源于我一个真实需求 比如说这是个天气信息展示，需要在一行内同一个地方展示风力和湿度。看起来就是一行字待 2 秒，然后向上移动渐变消失，同时另一行字从下面渐变向上出现移动到同一位置，如此循环展示。 难点是风力和湿度字数不定，所以就没办法让它固定宽度。而且初始位置是重叠的，并且动画已经占用了transform，上面方案二用不了了，有点难弄 1234&lt;div class=&quot;humidity-wind&quot;&gt; &lt;div class=&quot;humidity&quot;&gt;湿度 45%&lt;/div&gt; &lt;div class=&quot;wind&quot;&gt;东南风 1级&lt;/div&gt;&lt;/div&gt; 我是这么写的 css 123456789101112131415161718192021222324252627282930313233343536373839404142.humidity-wind &#123; height: 2vh; width: 100vw; position: relative; /* 使风向和湿度居中，我去居然能这么写，医学奇迹啊 */ display: flex; justify-content: center;&#125;.humidity-wind &gt; .humidity,.humidity-wind &gt; .wind &#123; position: absolute; animation: scroll-up 10s linear infinite; white-space: nowrap;&#125;.humidity-wind &gt; .wind &#123; opacity: 0; transform: translateY(100%); animation-delay: 5s; /* 风向动画延迟，确保湿度消失后开始 */&#125;@keyframes scroll-up &#123; 0% &#123; transform: translateY(100%); opacity: 0; &#125; 5% &#123; transform: translateY(0); opacity: 1; &#125; 50% &#123; transform: translateY(0); opacity: 1; &#125; 55% &#123; transform: translateY(-100%); opacity: 0; &#125; 100% &#123; transform: translateY(-100%); opacity: 0; &#125;&#125; 重点就是这了 12display: flex;justify-content: center; 这些和position: absolute同时使用。可以尝试一下，如果去掉动画的 transform 的话，是两个 div 重叠居中的。 我以前一直以为设了定位就脱标了，flex 不能影响到，没想到啊，是能同时用的 看 GPT4 解释的是，子元素使用了 position: absolute，那么这个子元素会相对于这个容器进行定位，并且也会继承容器的 align-items 和 justify-content 属性 总之很有意思，记一下 JavaScriptJS 读元素 css 属性使用 xxx.style 的方法只能读到内联的 css，外联读出来全是空的 可以用getComputedStyle(elem, [pseudo]) 返回一个对象，包含所有 style。比如： 1234let computedStyle = getComputedStyle(document.body);console.log(computedStyle.marginTop); // 5pxconsole.log(computedStyle.color); // rgb(255, 0, 0) .reduce() 方法arr.reduce(function(accumulator, item, index, array) &#123; // ...&#125;, [initial]); accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。(相当于一个累加器) item —— 当前的数组元素。 index —— 当前索引。 arr —— 数组本身。 .replace 方法str.replace(regexp, replacement) 使用 replacement 替换在字符串 str 中找到的 regexp 的匹配项（如果带有修饰符 g 则替换所有匹配项，否则只替换第一个） .split 方法str.split(分隔符) 用以创建一个以分隔符为分割标志的数组 .join 方法arr.join(插入符) 返回一个字符串，这个字符串是由数组所有元素拼成，中间夹着插入符 如果不写就默认用,间隔，让它没有的话得写空字符串&#39;&#39; Array.prototype.slice.call()可将类数组(arguments,NodeList)，字符串(String)转换成数组。 为什么用它呢，因为比如 NodeList 缺像是 map 之类的数组方法，转化就能用了 Object.prototype.toString.call(fn) !&#x3D;&#x3D; ‘[object Function]’判断 fn 是不是函数 动态的居中问题比如说有个框，宽度定死了但是高度没定，你预先不知道有多少内容会给高度撑成多少，怎么上下的居中 可以先用定位，给他设置 top:50%，然后 js 给他负的边框，数值是自己的高度一半（当然是用 js 获取可视高度） xxxx.style.marginTop = &#39;-$&#123;xxxx.offsetHeight / 2&#125;px&#39; 展开运算符的覆写展开操作符...会将一个对象的所有可枚举属性复制到新的对象上。如果在展开操作符之后我们再定义一个与展开对象中同名的属性，那么这个新定义的属性的值将覆盖展开操作符复制过来的同名属性。 比如说 12345const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; ...obj1, b: 3, c: 4 &#125;;console.log(obj2); // 输出 &#123; a: 1, b: 3, c: 4 &#125; Object.entries() 方法Object.entries(要处理的对象) 接收一个对象作为参数，并返回一个数组。这个数组的每个元素都是另一个数组，其中包含对象中每个属性的键和值。如果传入的是一个空对象或没有属性的对象，它会返回一个空数组。 例如，假设有一个对象 obj = &#123; a: 1, b: 2 &#125;，那么 Object.entries(obj) 会返回 [[&#39;a&#39;, 1], [&#39;b&#39;, 2]]。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"原生h5","slug":"原生h5","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fh5/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"css","slug":"css","permalink":"http://wishao.fun/tags/css/"},{"name":"html","slug":"html","permalink":"http://wishao.fun/tags/html/"},{"name":"拾遗","slug":"拾遗","permalink":"http://wishao.fun/tags/%E6%8B%BE%E9%81%97/"}]},{"title":"Redux状态管理","slug":"Redux状态管理","date":"2023-07-12T13:36:33.000Z","updated":"2024-02-29T06:40:31.875Z","comments":true,"path":"2023/07/12/Redux状态管理/","link":"","permalink":"http://wishao.fun/2023/07/12/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","excerpt":"为了深入理解 Redux 状态管理工具，手写一个简化的（也是作业）","text":"为了深入理解 Redux 状态管理工具，手写一个简化的（也是作业） 手写一个类似 Redux 的 createStore，实现一个简单的列表增删。 输入名称，序号自增并以此名称添加进列表；输入要删除的序号，就删除对应序号的行 index.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;redux&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;add&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入名称&quot; /&gt; &lt;button&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;delete&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入要删除的id&quot; /&gt; &lt;button&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;show&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const addTextDOM = document.querySelector(&#x27;.add input&#x27;);const addBtnDOM = document.querySelector(&#x27;.add button&#x27;);const deleteTextDOM = document.querySelector(&#x27;.delete input&#x27;);const deleteBtnDOM = document.querySelector(&#x27;.delete button&#x27;);const showDOM = document.querySelector(&#x27;.show&#x27;);// 手写简单Reduxfunction createStore(reducer) &#123; // 闭包内数据，一个是所存数据，一个是注册的函数 // 初始化 state let state = reducer(undefined, &#123;&#125;); const listeners = []; // 从闭包里获取state的函数 const getState = () =&gt; state; // 核心，dispatch函数，使用传入的reducer更新state，同时触发所有注册的函数 const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach((listener) =&gt; listener()); &#125;; // 注册函数，返回一个取消注册的函数 const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; const index = listeners.indexOf(listener); listeners.splice(index, 1); &#125;; &#125;; return &#123; getState, dispatch, subscribe &#125;;&#125;// 此例子的reducer，这里state进行了初始化，这样规定了state的数据结构// names数组里面放的是有id和name俩属性的对象function reducer(state = &#123; id: 0, names: [] &#125;, action) &#123; switch (action.type) &#123; case &#x27;ADD&#x27;: return &#123; id: state.id + 1, names: [...state.names, &#123; id: state.id, name: action.name &#125;], &#125;; case &#x27;DELETE&#x27;: return &#123; // 这里重写了展开属性，覆盖了原来的names ...state, names: state.names.filter((item) =&gt; item.id !== action.id), &#125;; default: return state; &#125;&#125;// 利用手写的createStore函数创建storeconst store = createStore(reducer);// 渲染函数function render() &#123; const currentState = store.getState(); // 获取当前的状态 showDOM.innerHTML = currentState.names.map((item) =&gt; `&lt;p&gt;序号:$&#123;item.id&#125;，名称:$&#123;item.name&#125;&lt;/p&gt;`).join(&#x27;&#x27;);&#125;// 注册渲染的函数，同时返回一个取消注册的函数（虽然说没用到吧const unRender = store.subscribe(render);addBtnDOM.addEventListener(&#x27;click&#x27;, () =&gt; &#123; const name = addTextDOM.value; store.dispatch(&#123; type: &#x27;ADD&#x27;, name &#125;); addTextDOM.value = &#x27;&#x27;;&#125;);deleteBtnDOM.addEventListener(&#x27;click&#x27;, () =&gt; &#123; const id = Number(deleteTextDOM.value); store.dispatch(&#123; type: &#x27;DELETE&#x27;, id &#125;); deleteTextDOM.value = &#x27;&#x27;;&#125;);","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"原生h5","slug":"原生h5","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fh5/"},{"name":"暑假集训","slug":"暑假集训","permalink":"http://wishao.fun/tags/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.fun/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"}]},{"title":"Vue Pinia","slug":"Vue-Pinia","date":"2023-07-12T03:26:14.000Z","updated":"2024-02-29T05:03:50.987Z","comments":true,"path":"2023/07/12/Vue-Pinia/","link":"","permalink":"http://wishao.fun/2023/07/12/Vue-Pinia/","excerpt":"Vue 状态管理库 Pinia，非常好用","text":"Vue 状态管理库 Pinia，非常好用 PiniaPinia 是一款轻量级的 Vue 状态管理库，可以使用它跨组件或页面共享状态。 相当于组件的组件，可以用来定义一些共用的东西，也可以用来传递数据。 能用 vue3 的组合式语法来写，与本来的组件完全一致，非常直观好用 1. 引入先安装 1npm i pinia 然后在 main.js 引入 1234import &#123; createPinia &#125; from &#x27;pinia&#x27;;const app = createApp(App);app.use(pinia); 2. 基础使用一般来说，先在 src 文件夹里创建一个 stores 文件夹，专门存放 pinia 组件 比如定义一个计数器的组件，使用了组合式语法，定义一个响应式数据和一个方法 123456789101112131415import &#123; defineStore &#125; from &#x27;pinia&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123; const count = ref(0); const increment = () =&gt; &#123; count.value++; &#125;; return &#123; count, increment, &#125;;&#125;); 步骤是先引入defineStore，使用它定义一个组件供导出使用 然后在 vue 文件里导入useCounterStore，使用变量接收，就能像这样使用了 1234567891011&lt;script setup&gt;import &#123; useCounterStore &#125; from &#x27;./stores/counter&#x27;;const counterStore = useCounterStore();console.log(counterStore);&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;counterStore.increment&quot;&gt;&#123;&#123; counterStore.count &#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 3. getters 实现使用computed计算属性实现，然后导出，比如 1const doubleCount = computed(() =&gt; count.value * 2); 4. 异步请求比如网络请求 axios，直接在 store 里面写，写完导出，就能直接在引入的地方用了 5. 解构赋值看之前的代码，引入使用的时候每次都要写counterStore.xxx，很啰嗦。 可以使用解构赋值来赋值给变量 123const &#123; count, doubleCount &#125; = storeToRefs(counterStore);// 注意，这个方法只能获取到响应式数据，没法获得方法// 获取方法，比如increment，直接不用这个函数，直接解构赋值就行了（因为是引用值） 注意要用它的storeToRefs方法，不然直接写的话会丢失响应式数据的特性。获取到的是响应式对象","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假集训","slug":"暑假集训","permalink":"http://wishao.fun/tags/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.fun/tags/vue/"},{"name":"自学","slug":"自学","permalink":"http://wishao.fun/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"js基础复习","slug":"js基础复习","date":"2023-07-11T12:30:37.000Z","updated":"2024-02-29T05:04:12.381Z","comments":true,"path":"2023/07/11/js基础复习/","link":"","permalink":"http://wishao.fun/2023/07/11/js%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","excerpt":"复习原生 js 知识","text":"复习原生 js 知识 1. this 指向问题里的 call apply bindcallcall是一个方法，它的作用是改变函数的this指向。第一个参数是用于替换this的值，后续的参数是传递给函数的参数。例如： 1234567function showName(age, job) &#123; console.log(`My name is $&#123;this.name&#125;, I&#x27;m $&#123;age&#125; years old and I am a $&#123;job&#125;.`);&#125;let person = &#123; name: &#x27;Tom&#x27; &#125;;showName.call(person, 25, &#x27;engineer&#x27;); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. call会立即执行函数。 applyapply方法的作用和call类似，都是用于改变函数的this指向，不过apply接收的参数是一个数组（或类数组对象），第一个参数同样是用于替换this的值，第二个参数是传递给函数的参数数组。例如： 1234let person = &#123; name: &#x27;Tom&#x27; &#125;;let args = [25, &#x27;engineer&#x27;];showName.apply(person, args); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. 和call一样，apply也会立即执行函数。 bindbind方法也是用于改变函数的this指向，它的使用方法和call类似，第一个参数是用于替换this的值，后续的参数是传递给函数的参数。不过，不同于call和apply，bind不会立即执行函数，而是返回一个新的函数。例如： 12345let person = &#123; name: &#x27;Tom&#x27; &#125;;let newShowName = showName.bind(person, 25, &#x27;engineer&#x27;);newShowName(); // 输出: My name is Tom, I&#x27;m 25 years old and I am a engineer. 总结： call和apply的主要作用都是改变函数的this指向，并立即执行函数。它们的区别主要在于参数的传递方式，call是将参数依次传入，而apply则是以数组形式传入参数。 bind方法也可以改变函数的this指向，但不同的是，它会返回一个新的函数，可以在需要的时候再去调用这个新函数。 2. 事件等级DOM 0 级事件DOM 0 级事件又称为原始事件模型，其事件绑定方法非常简单，直接在 HTML 元素上通过事件属性（如 onclick、onload、onmouseover 等）绑定 JavaScript 函数，或者在 JavaScript 代码中通过 JavaScript 对象的事件属性进行绑定。 例如： 12345678// 通过 HTML 属性直接指定&lt;button onclick=&quot;console.log(&#x27;Button clicked!&#x27;)&quot;&gt;Click me&lt;/button&gt;;// 通过 JavaScript 指定let button = document.getElementById(&#x27;myButton&#x27;);button.onclick = function () &#123; console.log(&#x27;Button clicked!&#x27;);&#125;; 注意，在使用 DOM 0 级事件时，同一个事件只能绑定一个处理函数，多次设置会覆盖之前的处理器。 DOM 2 级事件DOM 2 级事件提供了更多的事件类型和更丰富的事件处理方式。事件绑定主要使用 addEventListener 和 removeEventListener 方法。 addEventListener 方法接受三个参数：事件名称，事件处理函数，和一个布尔值（可以指定事件处理器在捕获阶段或者冒泡阶段执行）。 例如： 123456789let button = document.getElementById(&#x27;myButton&#x27;);// 添加事件处理器button.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;Button clicked!&#x27;);&#125;);// 移除事件处理器button.removeEventListener(&#x27;click&#x27;, handler); 不同于 DOM 0 级事件，DOM 2 级事件可以为同一个事件绑定多个处理函数，这些函数将按照绑定顺序依次执行。同时，可以通过 removeEventListener 移除绑定的事件处理函数。 DOM 3 级事件DOM 3 级事件在 DOM 2 的基础上，引入了更多的事件类型，例如键盘事件、鼠标滚轮事件等。有以下常见的几类： 鼠标事件：click、dblclick、mousedown、mouseup、mousemove、mouseover、mouseout、mouseenter、mouseleave 等。 键盘事件：keydown、keyup、keypress。 表单事件：focus、blur、change、submit。 窗口事件：scroll、resize、load、unload。 3. JavaScript 继承在 JavaScript 中，有多种方法实现对象的继承，其中包括原型链继承、组合继承、原型式继承、寄生式继承、寄生组合式继承，以及 ES6 中引入的基于 class 关键字的继承。 原型链继承JavaScript 的每个对象都有一个指向它的原型（prototype）的链接。当试图访问一个对象的属性时，如果对象内部没有这个属性，那么 JavaScript 就会去对象的原型上找这个属性，这个过程叫做原型链查找。 1234567891011121314151617function Parent() &#123; this.parentValue = &#x27;parent&#x27;;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child() &#123; this.childValue = &#x27;child&#x27;;&#125;// Child 继承自 ParentChild.prototype = new Parent();let child = new Child();console.log(child.getParentValue()); // &#x27;parent&#x27; 缺点：父类的引用属性会被所有实例共享，一个实例修改了父类的引用属性，其他实例的这个属性也会被修改。 组合继承（经典继承）组合继承是 JavaScript 最常用的继承模式。思路是使用原型链实现对原型属性和方法的继承，通过构造函数来实现对实例属性的继承。 12345678910111213141516171819function Parent(value) &#123; this.parentValue = value;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child(value, childValue) &#123; Parent.call(this, value); // 继承实例属性，第一次调用 Parent() this.childValue = childValue;&#125;// 继承方法Child.prototype = new Parent(); // 第二次调用 Parent()Child.prototype.constructor = Child;let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; 原型式继承原型式继承的思路是基于已经存在的对象创建新对象，同时还不必因此创建自定义类型。 123456789101112131415function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;let parent = &#123; parentValue: &#x27;parent&#x27;, getParentValue: function () &#123; return this.parentValue; &#125;,&#125;;let child = object(parent);console.log(child.getParentValue()); // &#x27;parent&#x27; ES5 通过新增 Object.create() 方法规范化了原型式继承。 12345678910111213141516171819202122232425262728293031323334353637var parent = &#123; name: &#x27;parent&#x27;, getName: function () &#123; return this.name; &#125;, sayHello: function () &#123; console.log(&quot;Hello, I&#x27;m &quot; + this.name); &#125;,&#125;;// 创建新对象，并继承于parent对象var child = Object.create(parent);console.log(child.getName()); // 输出 &quot;parent&quot;child.sayHello(); // 输出 &quot;Hello, I&#x27;m parent&quot;// 可以给新对象添加新的属性或者覆盖继承来的属性var child2 = Object.create(parent, &#123; name: &#123; // 覆盖 name 属性 value: &#x27;child2&#x27;, enumerable: true, writable: true, configurable: true, &#125;, age: &#123; // 新增 age 属性 value: 10, enumerable: true, writable: true, configurable: true, &#125;,&#125;);console.log(child2.getName()); // 输出 &quot;child2&quot;child2.sayHello(); // 输出 &quot;Hello, I&#x27;m child2&quot;console.log(child2.age); // 输出 10 寄生式继承寄生式继承的思路是创建一个用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。 1234567891011function createAnother(original) &#123; var clone = object(original); clone.sayHi = function () &#123; console.log(&#x27;hi&#x27;); &#125;; return clone;&#125;let child = createAnother(parent);console.log(child.getParentValue()); // &#x27;parent&#x27;child.sayHi(); // &#x27;hi&#x27; 寄生组合式继承寄生组合式继承是将寄生式继承和组合继承进行组合应用的方法。这种类型的继承效率较高，是 JavaScript 中最理想的继承范式。 123456789101112131415161718192021222324function Parent(value) &#123; this.parentValue = value;&#125;Parent.prototype.getParentValue = function () &#123; return this.parentValue;&#125;;function Child(value, childValue) &#123; Parent.call(this, value); this.childValue = childValue;&#125;// 寄生组合式继承的核心(function () &#123; // 创建一个没有实例方法的 &quot;类&quot; var Super = function () &#123;&#125;; Super.prototype = Parent.prototype; // 让子类的原型等于 &quot;类&quot; 的实例, 实现继承 Child.prototype = new Super();&#125;)();let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; ES6 的 class 继承ES6 中，可以使用 class 关键字来定义类，并通过 extends 和 super 关键字来实现类的继承。 12345678910111213141516171819class Parent &#123; constructor(value) &#123; this.parentValue = value; &#125; getParentValue() &#123; return this.parentValue; &#125;&#125;class Child extends Parent &#123; constructor(value, childValue) &#123; super(value); // 调用父类的 constructor(value) this.childValue = childValue; &#125;&#125;let child = new Child(&#x27;parent&#x27;, &#x27;child&#x27;);console.log(child.getParentValue()); // &#x27;parent&#x27; class 继承的背后其实是原型链继承和构造函数继承的组合，是语法糖。 4. 事件循环JavaScript 是单线程语言，为了实现执行异步操作，所以引入了事件循环(Event Loop)。它是一个持续运行的过程，可以理解为一个实际的循环，它在等待事件发生时继续运行。 宏任务和微任务JavaScript 的任务可以分为宏任务和微任务 宏任务：可以理解为需要在一次事件循环中全部执行完毕的任务，例如setTimeout、setInterval、setImmediate(Node.js 环境)、I/O、UI rendering等。 微任务：可以理解为需要在当前任务执行结束后立即执行的任务，例如Promise、process.nextTick(Node.js 环境)、MutationObserver等。 事件循环过程 执行同步代码，这属于一个宏任务。 执行完所有同步代码后，执行下一个宏任务前，在下一个宏任务开始前，会执行所有的微任务。 当所有微任务执行完毕后，有可能需要进行 UI 渲染。 然后继续下一个宏任务，执行对应的任务队列。 循环上述步骤。 经典题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647console.log(&#x27;1&#x27;);setTimeout(function () &#123; console.log(&#x27;2&#x27;); process.nextTick(function () &#123; console.log(&#x27;3&#x27;); &#125;); new Promise(function (resolve) &#123; console.log(&#x27;4&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;5&#x27;); &#125;);&#125;);new Promise(function (resolve) &#123; console.log(&#x27;7&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;8&#x27;);&#125;);async function async1() &#123; console.log(&#x27;6&#x27;); await async2(); console.log(&#x27;9&#x27;);&#125;async function async2() &#123; console.log(&#x27;10&#x27;);&#125;process.nextTick(function () &#123; console.log(&#x27;11&#x27;);&#125;);async1();new Promise(function (resolve) &#123; console.log(&#x27;12&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;13&#x27;);&#125;);console.log(&#x27;14&#x27;);// 答案1 7 6 10 12 14 8 11 9 13 2 4 5 3 注意，await 后面的东西相当于new Promise(function(resolve) &#123;console.log(&#39;7&#39;);resolve();里面的console.log(&#39;7&#39;) 5. 模块化AMD (Asynchronous Module Definition)AMD 是 “Asynchronous Module Definition” 的缩写，意思就是 “异步模块定义”。它采用异步方式加载模块，模块的加载不影响后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。AMD 的代表实现是 RequireJS。 1234// 定义一个模块define(&#x27;module&#x27;, [&#x27;dep1&#x27;, &#x27;dep2&#x27;], function (dep1, dep2) &#123; return someExportedValue;&#125;); CMD (Common Module Definition)CMD 是 “Common Module Definition” 的缩写，也就是 “通用模块定义”。CMD 采用的是异步加载模块，允许模块和模块之间有依赖关系，也支持就近依赖，只有在用到某个模块的时候再去加载那个模块。CMD 的代表实现是 SeaJS。 1234define(function (require, exports, module) &#123; var dep1 = require(&#x27;dep1&#x27;); exports.action = function () &#123;&#125;;&#125;); CommonJSCommonJS 是 Node.js 模块系统的基础，它用于服务器。每个文件是一个模块，通过 require 来加载模块，通过 exports 或 module.exports 来导出模块。CommonJS 使用同步加载模块的方式。 12var dep1 = require(&#x27;dep1&#x27;);exports.someMethod = function () &#123;&#125;; ES6 ModulesES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。模块不是对象，import 命令会被 JavaScript 引擎静态分析，生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块去取值。 12import &#123; dep1, dep2 &#125; from &#x27;module-name&#x27;;export function someMethod() &#123;&#125; 6. 迭代器和生成器迭代器 (Iterator)迭代器是一种特殊对象，它包含一个叫做 next 的方法。这个方法返回一个结果对象，这个对象有两个属性： value：下一个值 done：布尔类型，如果没有更多的数据则为 true，否则为 false。 迭代器的简单示例： 1234567891011121314151617let iterator = &#123; current: 1, next() &#123; let result = &#123; value: null, done: true &#125;; if (this.current &lt;= 3) &#123; result.value = this.current; result.done = false; this.current++; &#125; return result; &#125;,&#125;;console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().done); // true 生成器（Generator）和 yield 关键字生成器是一种可以返回多个连续值的函数。换句话说，一个生成器就像一个工厂，制造一系列的值。生成器函数通过 * 符号来定义，并且可以通过 yield 关键字来产生一个值。 当一个生成器函数被调用时，它返回一个特殊类型的迭代器，称为生成器对象。这个对象也包含一个 next 方法，但是可以在生成器函数内部控制这个方法的行为。 生成器的简单示例： 12345678910111213141516171819202122// 例子1function* generator() &#123; yield 1; yield 2; yield 3;&#125;let iterator = generator();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().done); // true//例子2function* generator() &#123; const dataIn = yield &#x27;This will be replaced by next() argument&#x27;; console.log(dataIn);&#125;const iter = generator();console.log(iter.next()); // 输出 &#123; value: &#x27;This will be replaced by next() argument&#x27;, done: false &#125;iter.next(&#x27;Hello, generator!&#x27;); // 输出 &#x27;Hello, generator!&#x27; 每次调用生成器对象的 next 方法，就会执行生成器函数直到遇到一个 yield 语句。然后，yield 的值就是 next 方法返回的值。当没有更多的 yield 语句时，done 属性的值就会变成 true。 next() 函数还可以接收一个参数，这个参数可以作为 yield 语句的结果返回给生成器内部。这个特性可以使得生成器和外部环境进行双向的数据交换。比如例子 2 里调用 iter.next(&#39;Hello, generator!&#39;)，传入的参数 &#39;Hello, generator!&#39; 会作为上一次 yield 语句的结果，赋值给 dataIn 变量。然后生成器恢复执行，直到遇到下一个 yield 语句，或者结束。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"八股文","slug":"web前端/八股文","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"暑假集训","slug":"暑假集训","permalink":"http://wishao.fun/tags/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"八股文","slug":"八股文","permalink":"http://wishao.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"}]},{"title":"初识vue","slug":"初识vue","date":"2023-07-10T11:00:41.000Z","updated":"2024-02-29T05:04:26.050Z","comments":true,"path":"2023/07/10/初识vue/","link":"","permalink":"http://wishao.fun/2023/07/10/%E5%88%9D%E8%AF%86vue/","excerpt":"第一天 学习了 vue 基础语法以及 vue3 的组合式 API","text":"第一天 学习了 vue 基础语法以及 vue3 的组合式 API 一、vue 基础1、引入 vue基础不使用任何脚手架，直接在头部使用&lt;script src=&quot;https://unpkg.com/vue@3&quot;&gt;&lt;/script&gt;引入 vue 在 body 标签里建立一个 id 为 app 的 div，随后在 script 标签里使用Vue.createApp().mount(&#39;#app&#39;)这就是 vue 的最基础的引入 2、最简单的使用在 Vue.createApp()中传入对象，对象里添加 data 方法，return 的就是 vue 基本数据。 1234567891011Vue.createApp(&#123; data() &#123; return &#123; foods: [ &#123; id: 1, name: &#x27;原味鱿鱼丝&#x27;, image: &#x27;./images/原味鱿鱼丝.png&#x27;, purchased: false &#125;, &#123; id: 2, name: &#x27;辣味鱿鱼丝&#x27;, image: &#x27;./images/辣味鱿鱼丝.png&#x27;, purchased: false &#125;, &#123; id: 3, name: &#x27;炭烧味鱿鱼丝&#x27;, image: &#x27;./images/炭烧味鱿鱼丝.png&#x27;, purchased: false &#125;, ], &#125;; &#125;,&#125;).mount(&#x27;#app&#x27;); 随后便可以在那个绑定的 div 中使用基础 vue 语法。 并且这里的对象不只有 data 方法，还有若干别的方法，方便拆分管理 3、v-for v-bind v-modelv-for 指令v-for 用于渲染列表，基本语法如下： 123&lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/li&gt;&lt;/ul&gt; v-for 会遍历 items 数组，并为每个元素生成一个 &lt;li&gt; 元素。每个元素都通过 item 变量可以在模板中访问。key 属性是必需的，用于提高 Vue 追踪每个节点的能力，从而提高渲染性能。 v-bind 指令v-bind 用于绑定元素属性，基本语法如下： 1&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; v-bind 将元素的 disabled 属性绑定到 Vue 实例的 isButtonDisabled 属性。如果 isButtonDisabled 属性的值是 true，则按钮会被禁用。它常用来动态设置 HTML 属性。 简写形式是 :： 1&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 非常常用的是绑定数据，还有绑定 class 类名 v-model 指令v-model 用于实现双向数据绑定，基本语法如下： 1&lt;input v-model=&quot;message&quot; /&gt; v-model 将 input 的 value 属性和 input 的 oninput 事件绑定到 Vue 实例的 message 属性。这样当 input 值发生变化时，message 属性也会随之更新；反之亦然。 v-model 是 Vue 提供的一种特殊语法糖，本质上它是 v-bind 和 v-on 的结合。 4、v-on v-ifv-on 指令能在 html 上绑定方法。所绑定的方法写在 App 对象里的 methods 属性里。比如 1&lt;form v-on:submit=&quot;add&quot;&gt;&lt;/form&gt; 可以缩写成@。然后再加上 form 表单触发 submit 事件的时候默认会刷新页面，但是我们不需要它提交表单，所以用 vue 提供的方法之间阻止，写成： 1&lt;form @submit.prevent=&quot;add&quot;&gt;&lt;/form&gt; v-if 指令就是把 js 能做的判断能写到 html 标签里，如果满足才显示这个标签。比如 1&lt;div v-if=&quot;items.length &gt; 3&quot;&gt;&lt;/div&gt; 满足 items 的长度的时候才显示这个 div 标签 还有 v-else-if 与 v-else 可以用，不过多赘述 5、拆分组件这是 vue 最核心的思想。比如首先可以把基础导入写成Vue.createApp(App).mount(&#39;#app&#39;)，然后就可以新建一个文件 App.js，把东西都写在这里。然后使用 es6 的导出导入语法挂载 在 App 对象里，添加 template 属性，属性是反引号字符串，然后就可以把所有之前写在 id 为 app 的 div 里的 html 写在反引号里了。vue 会为我们挂载并使用 6、细化拆分再在这个 app.js 写多了东西感觉复杂，还能细化拆分。把 App 对象里的所有东西都删除，只留一个 template 属性，再加一个 components 方法，用 es6 的导入对象，这就是要引入的东西。再新建个文件，写和 app.js 类似的对象导出。把传入的对象写成 html 标签写入 App 的 template 里，实现了组件进一步细化拆分 7、父子组件通信父传子在父组件的 template 里，写子组件的 html 标签时，添加一个属性。比如 1&lt;son :message=&quot;mes1&quot;&gt;&lt;/son&gt; 然后在子组件里添加一个 props 属性，是个对象，对象里是信息的名加上信息类型，就能传入信息了。比如 12345&#123; props: &#123; mes1: String, &#125;&#125; 子传父使用$emit方法，子组件可以向父组件发送事件。这个方法接收两个参数，第一个参数是事件的名称，第二个参数是随事件一起发送的数据。当子组件调用 $emit 方法时，会触发一个事件，这个事件会向上冒泡到父组件，父组件可以通过 v-on 或者 @ 对这个事件进行监听，并在回调函数中接收数据，完成子组件到父组件的通信。举例： 子组件： 12345678910&#123; template: ` &lt;button @click=&quot;notifyParent&quot;&gt;Click me&lt;/button&gt; ` methods: &#123; notifyParent() &#123; this.$emit(&#x27;childClicked&#x27;, &#x27;Hello, parent!&#x27;); &#125; &#125;&#125; 父组件： 1234567891011121314import ChildComponent from &#x27;./ChildComponent.vue&#x27;;export default &#123; components: &#123; ChildComponent, &#125;, template: ` &lt;child-component @childClicked=&quot;handleChildClick&quot;&gt;&lt;/child-component&gt; `, methods: &#123; handleChildClick(message) &#123; console.log(message); // 输出 &#x27;Hello, parent!&#x27; &#125;, &#125;,&#125;; 能够点击子组件按钮，控制台输出 Hello, parent! 感觉这个语法比较费解，大致过程是： 首先，在最终要点击的子组件上绑定函数 然后在这个函数上，使用$emit 方法，第一个参数是传递的名称，第二个参数是传递的信息。这样做等于是向调用它的人暴露出了第一个参数命名的属性 再然后，在父组件里，导入子组件，在 template 中使用此组件，并用 v-on，父组件的方法监听暴露出来的属性。 这时候，父组件监听函数的定义里参数便是子组件传递的信息（即第二个参数），便能在父组件做一些事情。每当子组件的函数被调用，父组件的监听函数也就跟着被调用，完成了子传父。 二、vue3 组合式 API 基础1、安装运行使用 creat-vue 脚手架构建(基于 Vite) 1npm init vue@latest 2、基本文件结构根目录 index.html 是最终入口，最后 vue 会把东西挂载至此 其他都是一些工程的配置文件 src在这里进行主要代码的书写 App.vue 根组件文件 main.js 项目的入口文件 components 文件夹 存放项目使用的公共组件 assets 文件夹 存放每个页面对应的 css、js 公共函数以及图片文件 public公共资源目录 dist存放打包好生成的文件 3、基本使用从 App.vue 开始vue3 使用了组合式语法，简化了 vue2 的语法。在 &lt;script&gt; 标签内编写 JavaScript，&lt;template&gt; 标签内编写 HTML。使用双大括号 &#123;&#123; &#125;&#125; 包含变量或语句。 响应式数据使用 reactive() 和 ref() 使 HTML 中的变量可变，即 JavaScript 更改变量后，HTML 会重新渲染新值。 ref()：创建一个响应式数据对象。ref() 返回的对象包含一个 .value 属性用于获取或设置内部值。 reactive()：接受一个普通对象并返回其代理，等同于 Vue 2.x 的Vue.observable()。 计算属性用于影响响应式数据。定义一个函数来更改响应式数据，得到的结果仍然是响应式的，可以在 HTML 中实时渲染。 使用 computed() 函数创建计算属性，这个函数接收一个 getter 函数并返回一个不可变的响应式 ref 对象。当依赖的响应式数据发生变化时，getter 函数会自动重新计算。 最好不要传入有副作用的函数。计算属性是只读的 监听使用 watch() 函数监听数据变化，数据发生变化时会触发回调函数。 1watch(xxx, (newVal, oldVal) =&gt; &#123;&#125;); immediate 参数：放在最后，如果指定了这个参数，将首先立即执行一次回调函数。 默认为浅层监听，即如果监听的是一个对象，对象的属性发生变化不会调用回调函数。如果要进行深度监听，需要指定 deep 参数。 如果需要精确监听某个属性，可以将回调函数改写为两个，第一个返回需要监听的属性。 生命周期函数 onBeforeMount(): 在挂载开始之前调用。 onMounted(): 在组件挂载到 DOM 后调用，可以访问和操作 DOM 元素。 onBeforeUpdate(): 在数据更新，导致的虚拟 DOM 重新渲染和打补丁之前调用。 onUpdated(): 在组件 DOM 已经更新，即数据的更改已经体现在 DOM 中之后调用。 onBeforeUnmount(): 新的生命周期函数，在组件卸载之前被调用，可以进行一些清理工作。 onUnmounted(): 在组件卸载并从 DOM 中移除后被调用。 注意： beforeCreate 和 created 在 Vue 3 的组合式 API 中没有直接的等价物。 组件父子通信 父传子：在调用子组件时，添加一个属性，即要传递的信息。子组件使用 defineProps() 来接收。如果是响应式数据，需要在添加属性时前面加一个冒号 :。 子传父：在父组件中定义变量，然后在使用子组件时添加一个属性来传递，子组件使用后可以传递信息。注意，使用子组件时需要在方法前加 @，然后子组件通过 defineEmits() 函数来生成传递方法。 模板引用为了获取 DOM 组件。 首先调用 ref() 函数，传入 null，然后在模板 HTML 中，用 ref 属性绑定该变量。这样我们就可以通过这个变量获取到 DOM。注意，需要在组件挂载完成后才能获取，所以要在 onMounted 生命周期或者之后。 跨层传递数据层组件使用 provide() 函数提供数据，provide(&#39;别名&#39;, 数据)。 底层组件使用 inject() 函数获取数据，inject(&#39;别名&#39;)。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"暑假集训","slug":"暑假集训","permalink":"http://wishao.fun/tags/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"http://wishao.fun/tags/vue/"},{"name":"自学","slug":"自学","permalink":"http://wishao.fun/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"紧急事件","slug":"紧急事件","date":"2023-07-09T18:08:30.000Z","updated":"2023-07-10T14:25:29.000Z","comments":true,"path":"2023/07/10/紧急事件/","link":"","permalink":"http://wishao.fun/2023/07/10/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"晚上才看见暑假里要每日写总结传博客，遂急忙搭建此站。目前一切都是临时的，后面再做理会。大改的东西有很多，顶部栏完全没弄，访问统计也没弄，友链，关于我之类的都还没，纯毛坯房，后面再加","categories":[{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.fun/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[{"name":"紧急事件","slug":"紧急事件","permalink":"http://wishao.fun/tags/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/"}],"author":"WiSHao"},{"title":"Hello World","slug":"hello-world","date":"2023-07-09T13:00:00.000Z","updated":"2023-07-15T13:37:00.646Z","comments":true,"path":"2023/07/09/hello-world/","link":"","permalink":"http://wishao.fun/2023/07/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.fun/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[],"author":"volantis"}],"categories":[{"name":"编译原理","slug":"编译原理","permalink":"http://wishao.fun/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"monkey.ts","slug":"编译原理/monkey-ts","permalink":"http://wishao.fun/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/monkey-ts/"},{"name":"瞎折腾","slug":"瞎折腾","permalink":"http://wishao.fun/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"minecraft","slug":"瞎折腾/minecraft","permalink":"http://wishao.fun/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/minecraft/"},{"name":"web前端","slug":"web前端","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"原生js","slug":"web前端/原生js","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9Fjs/"},{"name":"vue学习","slug":"web前端/vue学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"web前端/小程序","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Windows调教","slug":"瞎折腾/Windows调教","permalink":"http://wishao.fun/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/Windows%E8%B0%83%E6%95%99/"},{"name":"html5游戏","slug":"web前端/html5游戏","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/html5%E6%B8%B8%E6%88%8F/"},{"name":"TypeScript学习","slug":"web前端/TypeScript学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/TypeScript%E5%AD%A6%E4%B9%A0/"},{"name":"react学习","slug":"web前端/react学习","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/react%E5%AD%A6%E4%B9%A0/"},{"name":"八股文","slug":"web前端/八股文","permalink":"http://wishao.fun/categories/web%E5%89%8D%E7%AB%AF/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"建站之初","slug":"建站之初","permalink":"http://wishao.fun/categories/%E5%BB%BA%E7%AB%99%E4%B9%8B%E5%88%9D/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://wishao.fun/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"http://wishao.fun/tags/%E7%AC%94%E8%AE%B0/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://wishao.fun/tags/TypeScript/"},{"name":"monkey.ts","slug":"monkey-ts","permalink":"http://wishao.fun/tags/monkey-ts/"},{"name":"编译原理","slug":"编译原理","permalink":"http://wishao.fun/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"游戏","slug":"游戏","permalink":"http://wishao.fun/tags/%E6%B8%B8%E6%88%8F/"},{"name":"minecraft","slug":"minecraft","permalink":"http://wishao.fun/tags/minecraft/"},{"name":"neoforge","slug":"neoforge","permalink":"http://wishao.fun/tags/neoforge/"},{"name":"Pterodactyl","slug":"Pterodactyl","permalink":"http://wishao.fun/tags/Pterodactyl/"},{"name":"原生js","slug":"原生js","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fjs/"},{"name":"原生h5","slug":"原生h5","permalink":"http://wishao.fun/tags/%E5%8E%9F%E7%94%9Fh5/"},{"name":"手写还原","slug":"手写还原","permalink":"http://wishao.fun/tags/%E6%89%8B%E5%86%99%E8%BF%98%E5%8E%9F/"},{"name":"vue","slug":"vue","permalink":"http://wishao.fun/tags/vue/"},{"name":"css","slug":"css","permalink":"http://wishao.fun/tags/css/"},{"name":"vite","slug":"vite","permalink":"http://wishao.fun/tags/vite/"},{"name":"github","slug":"github","permalink":"http://wishao.fun/tags/github/"},{"name":"uni-app","slug":"uni-app","permalink":"http://wishao.fun/tags/uni-app/"},{"name":"小程序","slug":"小程序","permalink":"http://wishao.fun/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"支付宝小程序","slug":"支付宝小程序","permalink":"http://wishao.fun/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Windows10","slug":"Windows10","permalink":"http://wishao.fun/tags/Windows10/"},{"name":"Windows11","slug":"Windows11","permalink":"http://wishao.fun/tags/Windows11/"},{"name":"Defender","slug":"Defender","permalink":"http://wishao.fun/tags/Defender/"},{"name":"关闭","slug":"关闭","permalink":"http://wishao.fun/tags/%E5%85%B3%E9%97%AD/"},{"name":"小软件","slug":"小软件","permalink":"http://wishao.fun/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"自学","slug":"自学","permalink":"http://wishao.fun/tags/%E8%87%AA%E5%AD%A6/"},{"name":"canvas","slug":"canvas","permalink":"http://wishao.fun/tags/canvas/"},{"name":"暑假集训","slug":"暑假集训","permalink":"http://wishao.fun/tags/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"react","slug":"react","permalink":"http://wishao.fun/tags/react/"},{"name":"html","slug":"html","permalink":"http://wishao.fun/tags/html/"},{"name":"拾遗","slug":"拾遗","permalink":"http://wishao.fun/tags/%E6%8B%BE%E9%81%97/"},{"name":"八股文","slug":"八股文","permalink":"http://wishao.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"紧急事件","slug":"紧急事件","permalink":"http://wishao.fun/tags/%E7%B4%A7%E6%80%A5%E4%BA%8B%E4%BB%B6/"}]}